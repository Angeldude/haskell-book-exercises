<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Exercises and notes for book "Haskell Programming from first principles" - Unofficial</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<h1>Exercises and notes for book "Haskell Programming from first principles" - Unofficial</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_1_all_you_need_is_lambda">1 All you need is lambda</a>
<ul class="sectlevel2">
<li><a href="#_1_6_multiple_arguments">1.6 Multiple arguments</a></li>
</ul>
</li>
<li><a href="#_2_hello_haskell">2 Hello, Haskell!</a>
<ul class="sectlevel2">
<li><a href="#_2_4_functions">2.4 Functions</a></li>
<li><a href="#_2_5_infix">2.5 Infix</a></li>
<li><a href="#_2_6_declaring_values">2.6 Declaring values</a></li>
<li><a href="#_2_12_let_and_where">2.12 Let and where</a></li>
<li><a href="#_2_13_chapter_exercises">2.13 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_3_string">3 String</a>
<ul class="sectlevel2">
<li><a href="#_3_3_printing_simple_things">3.3 Printing simple things</a></li>
<li><a href="#_3_4_type_sigmatures_of_concatenation_functions">3.4 Type sigmatures of concatenation functions</a></li>
<li><a href="#_3_5_concatenation_and_scoping">3.5 Concatenation and scoping</a></li>
<li><a href="#_3_7_chapter_exercises">3.7 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_4_basic_datatypes">4 Basic datatypes</a>
<ul class="sectlevel2">
<li><a href="#_4_2_anatomy_of_a_data_declaration">4.2 Anatomy of a data declaration</a></li>
<li><a href="#_4_4_comparing_values">4.4 Comparing values</a></li>
<li><a href="#_4_7_chapter_exercises">4.7 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_5_types">5 Types</a>
<ul class="sectlevel2">
<li><a href="#_5_4_typeclass_constrained_type_variables">5.4 Typeclass-constrained type variables</a></li>
<li><a href="#_5_5_currying">5.5 Currying</a></li>
<li><a href="#_5_6_polymorphism">5.6 Polymorphism</a></li>
<li><a href="#_5_7_type_inference">5.7 Type inference</a></li>
<li><a href="#_5_9_chapter_exercises">5.9 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_6_typeclasses">6 Typeclasses</a>
<ul class="sectlevel2">
<li><a href="#_6_7_ord">6.7 Ord</a></li>
<li><a href="#_6_12_writing_instances_for_your_typeclasses">6.12 Writing instances for your typeclasses</a></li>
<li><a href="#_6_14_chapter_exercises">6.14 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_7_more_functional_patterns">7 More functional patterns</a>
<ul class="sectlevel2">
<li><a href="#_7_4_anonymous_functions">7.4 Anonymous functions</a></li>
<li><a href="#_7_5_pattern_matching">7.5 Pattern matching</a></li>
<li><a href="#_7_6_case_expressions">7.6 Case expressions</a></li>
<li><a href="#_7_7_higher_order_functions">7.7 Higher-order functions</a></li>
<li><a href="#_7_8_guards">7.8 Guards</a></li>
<li><a href="#_7_10_pointfree_style">7.10 Pointfree style</a></li>
<li><a href="#_7_12_chapter_exercises">7.12 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_8_recursion">8 Recursion</a>
<ul class="sectlevel2">
<li><a href="#_8_2_factorial">8.2 Factorial</a></li>
<li><a href="#_8_6_chapter_exercises">8.6 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_9_lists">9 Lists</a>
<ul class="sectlevel2">
<li><a href="#_9_5_using_ranges_to_construct_lists">9.5 Using ranges to construct lists</a></li>
<li><a href="#_9_6_extracting_portions_of_lists">9.6 Extracting portions of lists</a></li>
<li><a href="#_9_7_list_comprehensions">9.7 List comprehensions</a></li>
<li><a href="#_9_8_spines_and_non_strict_evaluation">9.8 Spines and non-strict evaluation</a></li>
<li><a href="#_9_9_transforming_lists_of_values">9.9 Transforming lists of values</a></li>
<li><a href="#_9_10_filtering_lists_of_values">9.10 Filtering lists of values</a></li>
<li><a href="#_9_11_zipping_lists">9.11 Zipping lists</a></li>
<li><a href="#_9_12_chapter_exercises">9.12 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_10_folding_lists">10 Folding lists</a>
<ul class="sectlevel2">
<li><a href="#_10_5_fold_left">10.5 Fold left</a></li>
<li><a href="#_10_6_how_to_write_fold_functions">10.6 How to write fold functions</a></li>
<li><a href="#_10_9_scans">10.9 Scans</a></li>
<li><a href="#_10_10_chapter_exercises">10.10 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_11_algebraic_datatypes">11 Algebraic datatypes</a>
<ul class="sectlevel2">
<li><a href="#_11_4_data_constructors_and_values">11.4 Data constructors and values</a></li>
<li><a href="#_11_5_what_s_a_type_and_what_s_data">11.5 What’s a type and what’s data?</a></li>
<li><a href="#_11_7_what_makes_these_datatypes_algebraic">11.7 What makes these datatypes algebraic?</a></li>
<li><a href="#_11_8_sum_types">11.8 Sum types</a></li>
<li><a href="#_11_9_product_types">11.9 Product types</a></li>
<li><a href="#_11_10_normal_form">11.10 Normal form</a></li>
<li><a href="#_11_11_constructing_and_deconstructing_values">11.11 Constructing and deconstructing values</a></li>
<li><a href="#_11_12_function_type_is_exponential">11.12 Function type is exponential</a></li>
<li><a href="#_11_15_binary_tree">11.15 Binary Tree</a></li>
<li><a href="#_11_16_chapter_exercises">11.16 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_12_signaling_adversity">12 Signaling adversity</a>
<ul class="sectlevel2">
<li><a href="#_12_5_chapter_exercises">12.5 Chapter Exercises</a></li>
</ul>
</li>
<li><a href="#_13_building_projects_in_haskell">13 Building projects in Haskell</a>
<ul class="sectlevel3">
<li><a href="#_differences_between_cabal_and_stack">Differences between cabal and stack</a></li>
<li><a href="#_13_2_managing_projects_with_cabal">13.2 Managing projects with Cabal</a></li>
<li><a href="#_13_4_importing_modules">13.4 Importing modules</a></li>
<li><a href="#_13_8_loading_code_from_another_project">13.8 Loading code from another project</a></li>
<li><a href="#_13_9_do_syntax_and_io">13.9 do syntax and IO</a></li>
<li><a href="#_13_15_chapter_exercises">13.15 Chapter exercises</a></li>
</ul>
</li>
<li><a href="#_14_testing">14 Testing</a>
<ul class="sectlevel2">
<li><a href="#_14_3_conventional_testing">14.3 Conventional testing</a></li>
<li><a href="#_14_5_morse_code">14.5 Morse code</a></li>
<li><a href="#_14_6_chapter_exercises">14.6 Chapter Exercises</a></li>
<li><a href="#_hangman_testing">Hangman testing</a></li>
</ul>
</li>
<li><a href="#_15_monoid_semigroup">15 Monoid, Semigroup</a>
<ul class="sectlevel2">
<li><a href="#_15_10_reusing_algebras_by_asking_for_algebras">15.10 Reusing algebras by asking for algebras</a></li>
<li><a href="#_15_11_madness">15.11 Madness</a></li>
<li><a href="#_15_12_better_living_through_quickcheck">15.12 Better living through QuickCheck</a></li>
<li><a href="#_15_14_chapter_exercises">15.14 Chapter exercises</a></li>
</ul>
</li>
<li><a href="#_16_functor">16 Functor</a>
<ul class="sectlevel2">
<li><a href="#_116_4_let_s_talk_about_f_baby">116.4 Let’s talk about f , baby</a></li>
<li><a href="#_16_7_commonly_used_functors">16.7 Commonly used functors</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is <strong>UNOFFICIAL</strong>. In this document you will find finished exercises (hopefully without bugs) and notes for the book <strong>Haskell Programming from first principles</strong> from <strong>Chris Allen</strong> and <strong>Julie Monoruki</strong>. More details about the book and a place where to purchase it - <a href="http://haskellbook.com/" class="bare">http://haskellbook.com/</a></p>
</div>
<div class="paragraph">
<p>Sources for this documents are at <a href="https://github.com/lukleh/haskell-book-excercises" class="bare">https://github.com/lukleh/haskell-book-excercises</a></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
These are my personal notes and solved exercises for the book. I did this for myself and thought it may as well help others. I claim nothing. As I progress in book, I try to update this document.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This document is written in asciidoc, use Asciidoctor to build <code>asciidoctor index.adoc</code>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_all_you_need_is_lambda">1 All you need is lambda</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_1_6_multiple_arguments">1.6 Multiple arguments</h3>
<div class="sect3">
<h4 id="_intermission_exercises">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>b) <code>λxy.xz</code> equals <code>λmn.mz</code></p>
</li>
<li>
<p>c) <code>λxy.xxy</code> equals <code>λa(λb).aab</code> although it should be <code>λa(λb.aab)</code> I think</p>
</li>
<li>
<p>b) <code>λxyz.zx</code> equals <code>λtos.st</code>
=== 1.11 Exercises
==== Combinators
Combinator is lambda term with no free variable</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>λxyz.xz(yz) &#8594; λyz.yz(z) &#8594; λz.zz</code></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>λx.xxx</code> - yes</p>
</li>
<li>
<p><code>λxy.zx</code> - no, <code>z</code> not in head</p>
</li>
<li>
<p><code>λxyz.xy(zx)</code> - yes</p>
</li>
<li>
<p><code>λxyz.xy(zxy)</code> - yes</p>
</li>
<li>
<p><code>λxy.xy(zxy)</code> - no, <code>z</code> not in head</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_normal_form_or_diverge">Normal form or diverge</h4>
<div class="paragraph">
<p>Diverge - reduction does not end</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>λx.xxx</code> - converge, no reduction</p>
</li>
<li>
<p><code>(λz.zzz)(λy.yy)</code> - diverge, <code>(λz.zzz)(λy.yy) &#8594; (λy.yy)(λy.yy)(λy.yy) &#8594; λy.yy)(λy.yy(λy.yy)</code> into more nested expressions</p>
</li>
<li>
<p><code>(λx.xxx)z</code> - converge, <code>(λx.xxx)z &#8594; zzz</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_beta_reduce">Beta reduce</h4>
<div class="paragraph">
<p>Reduce in normal order, that is leftmost outermost first. Otherwise you get different results.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>(λabc.cba)zz(λwv.w) &#8594; (λc.czz)(λwv.w) &#8594; (λwv.w)zz &#8594; z</code></p>
</li>
<li>
<p><code>(λx.λy.xyy)(λa.a)b &#8594; (λy.(λa.a)yy)b &#8594; (λa.a)bb &#8594; bb</code></p>
</li>
<li>
<p><code>(λy.y)(λx.xx)(λz.zq) &#8594; (λx.xx)(λz.zq) &#8594; (λz.zq)(λz.zq) &#8594; (λz.zq)q &#8594; qq</code></p>
</li>
<li>
<p><code>(λz.z)(λz.zz)(λz.zy) &#8594; (λz.zz)(λz.zy) &#8594; (λz.zy)(λz.zy) &#8594; (λz.zy)y &#8594; yy</code></p>
</li>
<li>
<p><code>(λx.λy.xyy)(λy.y)y &#8594; (λy.(λy.y)yy)y &#8594; (λy.y)yy &#8594; yy</code></p>
</li>
<li>
<p><code>(λa.aa)(λb.ba)c &#8594; (λb.ba)(λb.ba)c &#8594; ((λb.ba)a)c &#8594; aac</code></p>
</li>
<li>
<p><code>(λxyz.xz(yz))(λx.z)(λx.a) &#8594; (λyz1.(λx.z)z1(yz1))(λx.a) &#8594; (λz1.(λx.z)z1λx.a)z1 &#8594; (λz1.zλx.a)z1 &#8594; λz1.za</code></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2_hello_haskell">2 Hello, Haskell!</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_2_4_functions">2.4 Functions</h3>
<div class="sect3">
<h4 id="_intermission_exercises_2">Intermission: Exercises</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">let half x = x / 2

let square x = x * x</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">dpi x = 3.14 * (x * x)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_5_infix">2.5 Infix</h3>
<div class="sect3">
<h4 id="_associativity_and_precedence">Associativity and precedence</h4>
<div class="paragraph">
<p>Higher precedence is applied first. Scale is 0-9.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">Prelude&gt; :info (^)
(^) :: (Num a, Integral b) =&gt; a -&gt; b -&gt; a   -- Defined in ‘GHC.Real’
infixr 8 ^</code></pre>
</div>
</div>
<div class="paragraph">
<p>Left associative</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">2 * 3 * 4
-- is evaluated as if it was
(2 * 3) * 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Right associative</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">Prelude&gt; 2 ^ 3 ^ 4
2417851639229258349412352
Prelude&gt; 2 ^ (3 ^ 4)
2417851639229258349412352
Prelude&gt; (2 ^ 3) ^ 4
4096</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_intermission_exercises_3">Intermission: Exercises</h4>
<div class="paragraph">
<p>they differ</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">8 + 7 * 9 = 71
(8 + 7) * 9 = 135</code></pre>
</div>
</div>
<div class="paragraph">
<p>they are the same</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">perimeter x y = (x * 2) + (y * 2)
perimeter x y = x * 2 + y * 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>they differ</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f x = x / 2 + 9
f x = x / (2 + 9)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_6_declaring_values">2.6 Declaring values</h3>
<div class="paragraph">
<p>fix mistakes</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">let area x = 3. 14 * (x * x)
let area x = 3.14 * (x * x)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">let double x = b * 2
let double x = x * 2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">-- file ch02_2.6_1.hs
x = 7
 y = 10
f = x + y

Prelude&gt; :l ch02_2.6_1.hs
[1 of 1] Compiling Main             ( ch02_2.6_1.hs, interpreted )

ch02_2.6_1.hs:2:4: parse error on input ‘=’
Failed, modules loaded: none.

-- fixed
x = 7
y = 10
f = x + y</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_12_let_and_where">2.12 Let and where</h3>
<div class="sect3">
<h4 id="_intermission_exercises_4">Intermission: Exercises</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">let x = 5 in x
-- 5
let x = 5 in x * x
-- 25
let x = 5; y = 6 in x * y
-- 30
let x = 3; y = 1000 in x + 3
-- 6</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><strong>let</strong></code> rewritten to <code><strong>where</strong></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f1 = x
    where x = 5

f2 = x * x
    where x = 5

f3 = x * y
    where x = 5
          y = 6

f4 = x + 3
   where x = 3
         y = 1000</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_more_exercises">More exercises!</h4>
<div class="paragraph">
<p><code><strong>let</strong></code> rewritten to <code><strong>where</strong></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">--let x = 3; y = 1000 in x * 3 + y
f1 = x * 3 + y
    where x = 3
          y = 1000

--let y = 10; x = 10 * 5  + y in x * 5
f2 = x * 5
    where y = 10
          x = 10 * 5 + y

--let x = 7; y = negate x; z = y * 10 in z / x + y
f3 = z / x + y
    where x = 7
          y = negate x
          z = y * 10</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_13_chapter_exercises">2.13 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_parenthesization">Parenthesization</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>2 + 2 * 3 - 1</code> == <code>2 + (2 * 3) - 1</code></p>
</li>
<li>
<p><code>(^) 10 $ 1 + 1</code> == <code>(^) 10 (1 + 1)</code></p>
</li>
<li>
<p><code>2 ^ 2 * 4 ^ 5 + 1</code> == <code>( (2 ^ 2) * (4 ^ 5) ) + 1</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_equivalent_expressions">Equivalent expressions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>1 + 1 == 2</code></p>
</li>
<li>
<p><code>10 ^ 2 == 10 + 9 * 10</code></p>
</li>
<li>
<p><code>400 - 37 /= (-) 37 400</code></p>
</li>
<li>
<p><code>100 `div` 3 /= 100 / 3</code></p>
</li>
<li>
<p><code>2 * 5 + 18 /= 2 * (5 + 18)</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_more_fun_with_functions">More fun with functions</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">z = 7
x = y ^ 2
waxOn = x * 5
y = z + 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>to REPL</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">let z = 7
let y = z + 8
let x = y ^ 2
let waxOn = x * 5</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>waxOn == 1125</code></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>results of</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">10 + waxOn
-- 1135
(+10) waxOn
-- 1135
(-) 15 waxOn
-- -1110
(-) waxOn 15
-- 1110</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>triple</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">let triple x = x * 3
triple waxOn
-- 3375</code></pre>
</div>
</div>
</li>
<li>
<p>where waxOn</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">waxOn = x * 5
    where z = 7
          y = z + 8
          x = y ^ 2</code></pre>
</div>
</div>
</li>
<li>
<p>rest</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">waxOn = x * 5
    where z = 7
          y = z + 8
          x = y ^ 2

triple x = x * 3

waxOff x = triple x</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><strong>waxOff</strong></code> is <code><strong>triple</strong></code><br>
<code><strong>waxOff waxOn</strong></code> is <code><strong>triple waxOn</strong></code></p>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_string">3 String</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_3_printing_simple_things">3.3 Printing simple things</h3>
<div class="sect3">
<h4 id="_intermission_exercises_5">Intermission: Exercises</h4>
<div class="paragraph">
<p>all in scope</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>y</code> in scope for <code>z</code></p>
</li>
<li>
<p><code>h</code> is not in scope for <code>g</code></p>
</li>
<li>
<p>cannot be laoded with error: Not in scope: ‘d’</p>
</li>
<li>
<p><code>r</code> and <code>p</code> are in scope for <code>area</code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_4_type_sigmatures_of_concatenation_functions">3.4 Type sigmatures of concatenation functions</h3>
<div class="paragraph">
<p>fix errors</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">++ [1, 2, 3] [4, 5, 6]
-- fix
(++) [1, 2, 3] [4, 5, 6]

'&lt;3' ++ ' Haskell'
--fix
"&lt;3" ++ " Haskell"

concat ["&lt;3", " Haskell"]
-- working</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_5_concatenation_and_scoping">3.5 Concatenation and scoping</h3>
<div class="paragraph">
<p><code>Print3Broken</code> can be fixed simply by moving <code>greeting = "Yarrrrr"</code> to top level.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_7_chapter_exercises">3.7 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_readinx_syntax">Readinx syntax</h4>
<div class="paragraph">
<p>fix errors</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">concat [[1, 2, 3], [4, 5, 6]]
-- working

++ [1, 2, 3] [4, 5, 6]
-- fix
(++) [1, 2, 3] [4, 5, 6]

(++) "hello" " world"
-- working

["hello" ++ " world]
-- fix
["hello" ++ " world"]

4 !! "hello"
-- fix
"hello" !! 4

(!!) "hello" 4
-- working

take "4 lovely"
-- fix
take 4 "lovely"

take 3 "awesome"
-- working</code></pre>
</div>
</div>
<div class="paragraph">
<p>pair code and results</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">-- a) - d)
concat [[1 * 6], [2 * 6], [3 * 6]]
[6,12,18]

-- b) - c)
"rain" ++ drop 2 "elbow"
"rainbow"

-- c) - e)
10 * head [1, 2, 3]
10

-- d) - a)
(take 3 "Julie") ++ (tail "yes")
"Jules"

-- e) - b)
concat [tail [1, 2, 3], tail [4, 5, 6], tail [7, 8, 9]]
[2,3,5,6,8,9]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_building_functions">Building functions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>list manipulations</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">-- a)
"Curry is awesome" ++ "!" == "Curry is awesome!"

-- b)
"Curry is awesome!" !! 4 == "y"

-- c)
drop 9 "Curry is awesome!" == "awesome!"</code></pre>
</div>
</div>
</li>
<li>
<p>same code in file</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">c1 s = s ++ "!"

c2 s = s !! 4

c3 s = drop 9 s</code></pre>
</div>
</div>
</li>
<li>
<p>third letter</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">thirdLetter :: String -&gt; Char
thirdLetter x = x !! 2</code></pre>
</div>
</div>
</li>
<li>
<p>letter index</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">letterIndex :: Int -&gt; Char
letterIndex x = "Curry is awesome!" !! x</code></pre>
</div>
</div>
</li>
<li>
<p>make reverse function using <code>drop</code> and <code>take</code> for a fixed input. this point includes point 6.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Reverse where

rvrs :: String -&gt; String
rvrs x = concat [drop 9 x , " ", take 2 $ drop 6 x, " ", take 5 x]

main :: IO ()
main = print $ rvrs "Curry is awesome"</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_basic_datatypes">4 Basic datatypes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_4_2_anatomy_of_a_data_declaration">4.2 Anatomy of a data declaration</h3>
<div class="paragraph">
<p>given data type, answer</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Mood = Blah | Woot deriving Show</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>type constructor is <code>Mood</code></p>
</li>
<li>
<p>values are <code>Blah</code> and <code>Woot</code></p>
</li>
<li>
<p><code>:: Mood &#8594; Woot</code> to <code>:: Mood &#8594; Mood</code>, as <code>Woot</code> is value, not type</p>
</li>
<li>
<p>change mood</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Mood = Blah | Woot deriving Show
changeMood :: Mood -&gt; Mood
changeMood Blah = Woot
changeMood _ = Blah</code></pre>
</div>
</div>
</li>
<li>
<p>done :)</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_4_4_comparing_values">4.4 Comparing values</h3>
<div class="sect3">
<h4 id="_intermission_exercises_6">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>bug</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">not True &amp;&amp; true
-- fix
not True &amp;&amp; True</code></pre>
</div>
</div>
</li>
<li>
<p>bug</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">not (x = 6)
-- fix
not (x == 6)</code></pre>
</div>
</div>
</li>
<li>
<p>correct</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">(1 * 2) &gt; 5</code></pre>
</div>
</div>
</li>
<li>
<p>bug</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">[Merry] &gt; [Happy]
-- fix
["Merry"] &gt; ["Happy"]</code></pre>
</div>
</div>
</li>
<li>
<p>bug</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">[1, 2, 3] ++ "look at me!"
-- fix
['1', '2', '3'] ++ "look at me!"</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_4_7_chapter_exercises">4.7 Chapter Exercises</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">awesome = ["Papuchon", "curry", "Haskell"]
alsoAwesome = ["Quake", "The Simons"]
allAwesome = [awesome, alsoAwesome]</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>length</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>type signature</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">:: [a] -&gt; Int</code></pre>
</div>
</div>
</li>
<li>
<p>takes one argument</p>
</li>
<li>
<p>result is <code>Int</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>results</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>length [1, 2, 3, 4, 5] == 5</code></p>
</li>
<li>
<p><code>length [(1, 2), (2, 3), (3, 4)] == 3</code></p>
</li>
<li>
<p><code>length allAwesome == 2</code></p>
</li>
<li>
<p><code>length (concat allAwesome) == 5</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>second breaks</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">-- works
6 / 3
-- both values need to be Fractional, length returns Int
6 / length [1, 2, 3]</code></pre>
</div>
</div>
</li>
<li>
<p>fixed previous example</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">6 `div` length [1, 2, 3]</code></pre>
</div>
</div>
</li>
<li>
<p><code>2 + 3 == 5</code> type is <code>Bool</code> and result is <code>True</code> as <code>5 == 5</code></p>
</li>
<li>
<p>type is <code>Bool</code>, result is <code>False</code> as <code>8 /= 5</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">Prelude&gt; let x = 5
Prelude&gt; x + 3 == 5</code></pre>
</div>
</div>
</li>
<li>
<p>as follows</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">Prelude&gt; length allAwesome == 2
-- works - True
Prelude&gt; length [1, 'a', 3, 'b']
-- breaks on types, list cannot be heterogenic
Prelude&gt; length allAwesome + length awesome
-- works - 5
Prelude&gt; (8 == 8) &amp;&amp; ('b' &lt; 'a')
-- works - False
Prelude&gt; (8 == 8) &amp;&amp; 9
-- breaks - 9 is not a Bool</code></pre>
</div>
</div>
</li>
<li>
<p>palidrome function</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">isPalindrome :: (Eq a) =&gt; [a] -&gt; Bool
isPalindrome x = reverse x == x</code></pre>
</div>
</div>
</li>
<li>
<p>return absolute value</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myAbs :: Integer -&gt; Integer
myAbs x = if x &lt; 0 then negate x else x</code></pre>
</div>
</div>
</li>
<li>
<p>tuple function</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: (a, b) -&gt; (c, d) -&gt; ((b, d), (a, c))
f x y = ((snd x, snd y), (fst x, fst y))</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_reading_syntax">Reading Syntax</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>length + 1</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">x = (+)
f xs = w `x` 1
    where w = length xs</code></pre>
</div>
</div>
</li>
<li>
<p>identity</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">\x -&gt; x</code></pre>
</div>
</div>
</li>
<li>
<p>head</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">\ (x:xs) -&gt; x</code></pre>
</div>
</div>
</li>
<li>
<p>fst</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f (a, b) = a</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_match_the_function_names_to_their_types">Match the function names to their types</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>c) <code>Show a &#8658; a &#8594; String</code></p>
</li>
<li>
<p>b) <code>Eq a &#8658; a &#8594; a &#8594; Bool</code></p>
</li>
<li>
<p>a) <code>(a, b) &#8594; a</code></p>
</li>
<li>
<p>d) <code>Num a &#8658; a &#8594; a &#8594; a</code></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_types">5 Types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_5_4_typeclass_constrained_type_variables">5.4 Typeclass-constrained type variables</h3>
<div class="sect3">
<h4 id="_intermission_exercises_7">Intermission: Exercises</h4>
<div class="paragraph">
<p>pair functions and signatures</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>a) c)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">not :: Bool -&gt; Bool</code></pre>
</div>
</div>
</li>
<li>
<p>b) d)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">length :: [a] -&gt; Int</code></pre>
</div>
</div>
</li>
<li>
<p>c) b)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">concat :: [[a]] -&gt; [a]</code></pre>
</div>
</div>
</li>
<li>
<p>d) a)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">head :: [a] -&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>e) e)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_5_currying">5.5 Currying</h3>
<div class="paragraph">
<p>test like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">Prelude&gt; let f :: a -&gt; a -&gt; a -&gt; a; f = undefined
Prelude&gt; :t f undefined
f undefined :: a -&gt; a -&gt; a
Prelude&gt; :t f 1
f 1 :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; :t f (1 :: Int)
f (1 :: Int) :: Int -&gt; Int -&gt; Int</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_intermission_exercises_8">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>a)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: a -&gt; a -&gt; a -&gt; a
f 'a' :: Char -&gt; Char -&gt; Char</code></pre>
</div>
</div>
</li>
<li>
<p>d)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">g :: a -&gt; b -&gt; c -&gt; b
g 0 'c' "woot" :: Char</code></pre>
</div>
</div>
</li>
<li>
<p>d)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">h :: (Num a, Num b) =&gt; a -&gt; b -&gt; b
h 1.0 2 :: Num b =&gt; b</code></pre>
</div>
</div>
</li>
<li>
<p>c)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">h :: (Num a, Num b) =&gt; a -&gt; b -&gt; b
h 1 (5.5 :: Double) :: Double</code></pre>
</div>
</div>
</li>
<li>
<p>a)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">jackal :: (Ord a, Eq b) =&gt; a -&gt; b -&gt; a
jackal "keyboard" "has the word jackal in it" :: [Char]</code></pre>
</div>
</div>
</li>
<li>
<p>e)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">jackal :: (Ord a, Eq b) =&gt; a -&gt; b -&gt; a
jackal "keyboard" "has the word jackal in it" :: Eq b =&gt; b -&gt; [Char]</code></pre>
</div>
</div>
</li>
<li>
<p>d)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">kessel :: (Ord a, Num b) =&gt; a -&gt; b -&gt; a
kessel 1 2 :: (Num a, Ord a) =&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>a)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">kessel :: (Ord a, Num b) =&gt; a -&gt; b -&gt; a
kessel 1 (2 :: Integer) :: (Num a, Ord a) =&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>c)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">kessel :: (Ord a, Num b) =&gt; a -&gt; b -&gt; a
kessel (1 :: Integer) 2 :: Integer</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_6_polymorphism">5.6 Polymorphism</h3>
<div class="sect3">
<h4 id="_intermission_exercises_9">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>id</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: a -&gt; a
f a = a</code></pre>
</div>
</div>
</li>
<li>
<p>return first or second argument</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: a -&gt; a -&gt; a
f a b = a
f a b = b</code></pre>
</div>
</div>
</li>
<li>
<p>only one implementation, like id</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: a -&gt; b -&gt; b
f a b = b</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_7_type_inference">5.7 Type inference</h3>
<div class="sect3">
<h4 id="_intermission_exercises_10">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>[Char] &#8594; [Char]</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">(++) :: [a] -&gt; [a] -&gt; [a]
myConcat x = x ++ " yo"</code></pre>
</div>
</div>
</li>
<li>
<p><code>Fractional a &#8658; a &#8594; a</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">(*) :: Num a =&gt; a -&gt; a -&gt; a
myMult x = (x / 3) * 5</code></pre>
</div>
</div>
</li>
<li>
<p><code>Int &#8594; [Char]</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take :: Int -&gt; [a] -&gt; [a]
myTake x = take x "hey you"</code></pre>
</div>
</div>
</li>
<li>
<p><code>Int &#8594; Bool</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">(&gt;) :: Ord a =&gt; a -&gt; a -&gt; Bool
myCom x = x &gt; (length [1..10])</code></pre>
</div>
</div>
</li>
<li>
<p><code>Char &#8594; Bool</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool
myAlph x = x &lt; 'z'</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_9_chapter_exercises">5.9 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_multiple_choice">Multiple choice</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>c) value of type <code><strong>[a]</strong></code> is a list whose elements are all of some type <code><strong>a</strong></code></p>
</li>
<li>
<p>a) function of type <code><strong>[[a]] &#8594; [a]</strong></code> could take a list of strings as an argument</p>
</li>
<li>
<p>b) function of type <code><strong>[a] &#8594; Int &#8594; a</strong></code> returns one element of type <code>a</code> from a list</p>
</li>
<li>
<p>c) function of type <code><strong>(a, b) &#8594; a</strong></code> takes a tuple argument and returns the first value</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_determine_the_type">Determine the type</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>return value and type</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>54 :: Num a &#8658; a</code></p>
</li>
<li>
<p><code>(0, "doge) :: Num t &#8658; (t, [Char])</code></p>
</li>
<li>
<p><code>(0, "doge) :: (Integer, [Char])</code></p>
</li>
<li>
<p><code>False :: Bool</code></p>
</li>
<li>
<p><code>5 :: Int</code></p>
</li>
<li>
<p><code>False :: Bool</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>type is <code>Num a &#8658; a</code></p>
</li>
<li>
<p><code>y</code> is shadowed, type is <code>Num a &#8658; a &#8594; a</code></p>
</li>
<li>
<p>type is <code>Fractional &#8658; a :: a</code></p>
</li>
<li>
<p>type is <code>[Char]</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_does_it_compile">Does it compile?</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>wahoo = bigNum $ 10</code> breaks, because <code>bigNum</code> is a value, not a function</p>
</li>
<li>
<p>works fine in GHCI, should work too in file</p>
</li>
<li>
<p>breaks on <code>c = b 10</code>, <code>b</code> has value <code>5</code>, cannot apply value to a value</p>
</li>
<li>
<p>breaks on <code>b = 10000 * c</code>, <code>c</code> is not defined</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_type_variable_or_specific_type_constructor">Type variable or specific type constructor?</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>f :: zed &#8594; Zed &#8594; Blah</code> is fully polymorphic, concrete and concrete</p>
</li>
<li>
<p><code>f :: Enum b &#8658; a &#8594; b &#8594; C</code> is fully polymorphic, constrained polymorphic and concrete</p>
</li>
<li>
<p><code>f :: f &#8594; g &#8594; C</code> is fully polymorphic, fully polymorphic and concrete</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_write_a_type_signature">Write a type signature</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>functionH (x:_) = x</code> type signature <code>functionH :: [a] &#8594; a</code></p>
</li>
<li>
<p><code>functionC x y = if (x &gt; y) then True else False</code> type signature <code>functionC :: Ord a &#8658; a &#8594; a &#8594; Bool</code></p>
</li>
<li>
<p><code>functionS (x, y) = y</code> type signature <code>functionS :: (a, b) &#8594; b</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_given_a_type_write_the_function">Given a type, write the function</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>i :: a &#8594; a; i a = a</code> or <code>id</code></p>
</li>
<li>
<p><code>c :: a &#8594; b &#8594; a; c a _ = a</code></p>
</li>
<li>
<p><code>c'' :: b &#8594; a &#8594; b; c :: a &#8594; b &#8594; a</code> they are the same</p>
</li>
<li>
<p><code>c' :: a &#8594; b &#8594; b; c _ b = b</code></p>
</li>
<li>
<p><code>r :: [a] &#8594; [a]</code> possibly <code>r a = tail a</code> or <code>r a = reverse a</code></p>
</li>
<li>
<p><code>co :: (b &#8594; c) &#8594; (a &#8594; b) &#8594; (a &#8594; c); co = (.)</code></p>
</li>
<li>
<p><code>a :: (a &#8594; c) &#8594; a &#8594; a; a f x = x</code> basically ignore the first argument</p>
</li>
<li>
<p><code>a' :: (a &#8594; b) &#8594; a &#8594; b; a' = ($)</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_fix_it">Fix it</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Sing where

fstString :: [Char] -&gt; [Char]
fstString x = x ++ " in the rain"

sndString :: [Char] -&gt; [Char]
sndString x = x ++ " over the rainbow"

sing = if (x &gt; y) then fstString x else sndString y
    where x = "Singin"
          y = "Somewhere"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Sing where

fstString :: [Char] -&gt; [Char]
fstString x = x ++ " in the rain"

sndString :: [Char] -&gt; [Char]
sndString x = x ++ " over the rainbow"

sing = if (x &lt; y) then fstString x else sndString y
    where x = "Singin"
          y = "Somewhere"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Arith3Broken where

main :: IO ()
main = do
    print $ 1 + 2
    putStrLn $ show 10
    print (negate (-1))
    print ((+) 0 blah)
    where blah = negate 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_type_kwon_do">Type-Kwon-Do</h4>
<div class="paragraph">
<p>full example for this section, it is al only about type checking</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Woot

data Blah

f :: Woot -&gt; Blah
f = undefined

g :: (Blah, Woot) -&gt; (Blah, Blah)
g (x, y) = (x, f y)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>just a composition</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: Int -&gt; String
f = undefined

g :: String -&gt; Char
g = undefined

h :: Int -&gt; Char
h = g . f</code></pre>
</div>
</div>
</li>
<li>
<p>also a composition</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data A
data B
data C

q :: A -&gt; B
q = undefined

w :: B -&gt; C
w = undefined

e :: A -&gt; C
e = w . q</code></pre>
</div>
</div>
</li>
<li>
<p>once u got the point, it is kinda easy</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data X
data Y
data Z

xz :: X -&gt; Z
xz = undefined

yz :: Y -&gt; Z
yz = undefined

xform :: (X, Y) -&gt; (Z, Z)
xform (x, y) = (xz x, yz y)</code></pre>
</div>
</div>
</li>
<li>
<p>neat</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">munge :: (x -&gt; y) -&gt; (y -&gt; (w, z)) -&gt; x -&gt; w
munge f g = fst . g . f</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_typeclasses">6 Typeclasses</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_6_7_ord">6.7 Ord</h3>
<div class="sect3">
<h4 id="_intermission_exercises_11">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>will work, result <code><strong>5</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">max (length [1, 2, 3]) (length [8, 9, 10, 11, 12])</code></pre>
</div>
</div>
</li>
<li>
<p>will work, result <code><strong>LT</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">compare (3 * 4) (3 * 5)</code></pre>
</div>
</div>
</li>
<li>
<p>will not work, parameters are different type</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">compare "Julie" True</code></pre>
</div>
</div>
</li>
<li>
<p>will work, result <code><strong>False</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">(5 + 3) &gt; (3 + 6)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_12_writing_instances_for_your_typeclasses">6.12 Writing instances for your typeclasses</h3>
<div class="sect3">
<h4 id="_intermission_exercises_12">Intermission: Exercises</h4>
<div class="paragraph">
<p>Write the <code><strong>Eq</strong></code> instance for the datatype provided</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>TisAnInteger</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data TisAnInteger =
    TisAn Integer

instance Eq TisAnInteger where
    (==) (TisAn a) (TisAn b) = a == b</code></pre>
</div>
</div>
</li>
<li>
<p>TwoIntegers</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data TwoIntegers =
    Two Integer Integer

instance Eq TwoIntegers where
    (==) (Two a1 a2) (Two b1 b2) = a1 == b1 &amp;&amp; a2 == b2</code></pre>
</div>
</div>
</li>
<li>
<p>StringOrInt</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data StringOrInt =
    TisAnInt Int
  | TisAString String

instance Eq StringOrInt where
    (==) (TisAnInt a) (TisAnInt b) = a == b
    (==) (TisAString a) (TisAString b) = a == b
    (==) _ _ = False</code></pre>
</div>
</div>
</li>
<li>
<p>Pair a</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Pair a =
    Pair a a

instance Eq a =&gt; Eq (Pair a) where
    (==) (Pair a1 a2) (Pair b1 b2) = a1 == b1 &amp;&amp; a2 == b2</code></pre>
</div>
</div>
</li>
<li>
<p>Tuple a b</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Tuple a b =
    Tuple a b

instance (Eq a, Eq b) =&gt; Eq (Tuple a b) where
    (==) (Tuple a1 a2) (Tuple b1 b2) = a1 == b1 &amp;&amp; a2 == b2</code></pre>
</div>
</div>
</li>
<li>
<p>Which a</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Which a =
    ThisOne a
  | ThatOne a

instance Eq a =&gt; Eq (Which a) where
    (==) (ThisOne a) (ThisOne b) = a == b
    (==) (ThatOne a) (ThatOne b) = a == b
    (==) _ _ = False</code></pre>
</div>
</div>
</li>
<li>
<p>EitherOr a b</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data EitherOr a b =
    Hello a
  | Goodbye b

instance (Eq a, Eq b) =&gt; Eq (EitherOr a b) where
    (==) (Hello a) (Hello b) = a == b
    (==) (Goodbye a) (Goodbye b) = a == b
    (==) _ _ = False</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_14_chapter_exercises">6.14 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_multiple_choice_2">Multiple choice</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>c) The <code><strong>Eq</strong></code> class makes equality tests possible</p>
</li>
<li>
<p>a) allows any two values to be compared</p>
</li>
<li>
<p>a) Type of <code><strong>&gt;</strong></code> is <code><strong>Ord a &#8658; a &#8594; a &#8594; Bool</strong></code></p>
</li>
<li>
<p>c) the type of x is a tuple in <code><strong>x = divMod 16 12</strong></code></p>
</li>
<li>
<p>a) The typeclass <code><strong>Integral</strong></code> includes <code><strong>Int</strong></code> and <code><strong>Integer</strong></code> numbers - and <code>Word</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_does_it_typecheck">Does it typecheck?</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>data <code><strong>Person</strong></code> need to to be instance of <code><strong>Show</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Person = Person Bool deriving Show
printPerson :: Person -&gt; IO ()
printPerson person = putStrLn (show person)</code></pre>
</div>
</div>
</li>
<li>
<p>data <code><strong>Mood</strong></code> need to to be instance of <code><strong>Eq</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Mood = Blah
          | Woot deriving (Show, Eq)

settleDown x = if x == Woot
                then Blah
                else x</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>settleDown</strong></code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>inputs can be <code><strong>Woot</strong></code> or <code><strong>Blah</strong></code></p>
</li>
<li>
<p>type error <code>No instance for (Num Mood) arising from the literal ‘9’</code> - different types and <code>Mood</code> is not in <code>Num</code></p>
</li>
<li>
<p><code><strong>Blah &gt; Woot</strong></code> raises error, because <code><strong>Mood</strong></code> is not instance of <code><strong>Ord</strong></code></p>
</li>
</ol>
</div>
</li>
<li>
<p>following code type checks</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">type Subject = String
type Verb = String
type Object = String

data Sentence =
    Sentence Subject Verb Object
    deriving (Eq, Show)

s1 = Sentence "dogs" "drool"
s2 = Sentence "Julie" "loves" "dogs"</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_given_a_datatype_declaration_what_can_we_do">Given a datatype declaration, what can we do?</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Rocks =
    Rocks String deriving (Eq, Show)

data Yeah =
    Yeah Bool deriving (Eq, Show)

data Papu =
    Papu Rocks Yeah
    deriving (Eq, Show)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Does not typecheck, <code><strong>Papu</strong></code> parameters are not well constructed.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">phew = Papu "chases" True
-- fix
phew = Papu (Rocks "chases") (Yeah True)</code></pre>
</div>
</div>
</li>
<li>
<p>Does typecheck.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">truth = Papu (Rocks "chomskydoz")
             (Yeah True)</code></pre>
</div>
</div>
</li>
<li>
<p>Does typecheck.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">equalityForall :: Papu -&gt; Papu -&gt; Bool
equalityForall p p' = p == p'</code></pre>
</div>
</div>
</li>
<li>
<p>Does not typecheck, <code><strong>Papu</strong></code> is not an instance of <code><strong>Ord</strong></code>.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">comparePapus :: Papu -&gt; Papu -&gt; Bool
comparePapus p p' = p &gt; p'</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_match_the_types">Match the types</h4>
<div class="paragraph">
<p>can you substitute signature</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Value <code>1</code> cannot be an needs at least <code><strong>Num</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">i :: Num a =&gt; a
i = 1

i :: a
-- No instance for (Num a) arising from the literal ‘1’</code></pre>
</div>
</div>
</li>
<li>
<p>Value <code>1.0</code> cannot be an instance on <code><strong>Num</strong></code>, it does not work with all the sub classes of <code><strong>Num</strong></code>. For example <code>1.0</code> cannot be <code><strong>Int</strong></code>.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: Float
f = 1.0

f :: Num a =&gt; a
-- error: Could not deduce (Fractional a) arising from the literal ‘1.0’ from the context (Num a)</code></pre>
</div>
</div>
</li>
<li>
<p>Value <code>1.0</code> works for class <code>Fractional</code> and all it&#8217;s subclasses and instances, which is also <code>Float</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: Float
f = 1.0

f :: Fractional a =&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>Value <code>1.0</code> works for class <code>RealFrac</code> and all it&#8217;s subclasses and instances.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: Float
f = 1.0

f :: RealFrac a =&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>identity function works for all values/instances of all classes</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">freud :: a -&gt; a
freud x = x

freud :: Ord a =&gt; a -&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>identity function works for type <code><strong>Int</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">freud' :: a -&gt; a
freud' x = x

freud' :: Int -&gt; Int</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>myX</strong></code> is type <code><strong>Int</strong></code>, <code><strong>sigmund</strong></code> is then defined without type constraines, but the real type is <code><strong>a &#8594; Int</strong></code> so <code>a &#8594; a</code> breaks</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myX = 1 :: Int

sigmund :: Int -&gt; Int
sigmund x = myX

sigmund :: a -&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>myX</strong></code> is type <code><strong>Int</strong></code>, <code><strong>sigmund'</strong></code> is then defined with <code><strong>Num</strong></code> type constrain, but the real type is <code><strong>a &#8594; Int</strong></code> so <code>Num a &#8658; a &#8594; a</code> breaks</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myX = 1 :: Int

sigmund' :: Int -&gt; Int
sigmund' x = myX

sigmund' :: Num a =&gt; a -&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>works, <code><strong>Int</strong></code> is instance of <code><strong>Ord</strong></code> and signature of <code><strong>jung</strong></code> matches that of <code><strong>sort</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">jung :: Ord a =&gt; [a] -&gt; a
jung xs = head (sort xs)

jung :: [Int] -&gt; Int</code></pre>
</div>
</div>
</li>
<li>
<p>works, signature of <code><strong>young</strong></code> is the same as signature of <code><strong>sort</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">young :: [Char] -&gt; Char
young xs = head (sort xs)

young :: Ord a =&gt; [a] -&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>breaks, <code><strong>signifier</strong></code> is more constrained - by <code><strong>mySort</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">mySort :: [Char] -&gt; [Char]
mySort = sort

signifier :: [Char] -&gt; Char
signifier xs = head (mySort xs)

signifier :: Ord a =&gt; [a] -&gt; a</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_type_kwon_do_2">Type-Kwon-Do</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>we need function that does at the end <code>Eq a &#8658; a &#8594; a &#8594; Bool</code>, there are multiple implementation, choosing the most basic one <code>(==)</code>. we can also just ignore all the params and always return <code>Bool</code> like <code>True</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">chk :: Eq b =&gt; (a -&gt; b) -&gt; a -&gt; b -&gt; Bool
chk f a b = (f a) == b</code></pre>
</div>
</div>
</li>
<li>
<p>the trick here is to use <code>fromInteger</code> to get <code>Num a</code>. wondering how can you make more generic type from more concrete type&#8230;&#8203;.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">arith :: Num b =&gt; (a -&gt; b) -&gt; Integer -&gt; a -&gt; b
arith f i a = (f a) + (fromInteger i)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_more_functional_patterns">7 More functional patterns</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_7_4_anonymous_functions">7.4 Anonymous functions</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>all are equal</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">mTh x y z = x * y * z
mTh x y = \z -&gt; x * y * z
mTh x = \y -&gt; \z -&gt; x * y * z
mTh = \x -&gt; \y -&gt; \z -&gt; x * y * z</code></pre>
</div>
</div>
</li>
<li>
<p>d) type of <code><strong>mTh 3</strong></code> is</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">Num a =&gt; a -&gt; a -&gt; a</code></pre>
</div>
</div>
</li>
<li>
<p>as anonymous function</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">addOneIfOdd n = case odd n of
    True -&gt; (\x -&gt; x + 1) n
    False -&gt; n</code></pre>
</div>
</div>
</li>
<li>
<p>as anonymous function - two arguments</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">\x y -&gt; ((if x &gt; y then y else x) + 5)</code></pre>
</div>
</div>
</li>
<li>
<p>as anonymous function - three arguments nested</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">\f -&gt; \x -&gt; \y -&gt; f y x</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_7_5_pattern_matching">7.5 Pattern matching</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>given following declarations</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">k (x, y) = x
k1 = k ((4-1), 10)
k2 = k ("three", (1 + 2))
k3 = k (3, True)</code></pre>
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>type of <code><strong>k</strong></code> is <code><strong>(a, b) &#8594; a</strong></code></p>
</li>
<li>
<p>type of <code><strong>k2</strong></code> is <code><strong>String</strong></code> and is different from <code><strong>k1</strong></code> and <code><strong>k3</strong></code></p>
</li>
<li>
<p><code><strong>k3</strong></code> and <code><strong>k1</strong></code> will return <code><strong>3</strong></code></p>
</li>
</ol>
</div>
</li>
<li>
<p>completed definitions</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: (a, b, c) -&gt; (d, e, f) -&gt; ((a, d), (c, f))
f (a, b, c) (d, e, f) = ((a, d), (c, f))</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_7_6_case_expressions">7.6 Case expressions</h3>
<div class="sect3">
<h4 id="_intermission_exercises_13">Intermission: Exercises</h4>
<div class="paragraph">
<p>rewrite <code><strong>if-then-else</strong></code> expressions into case expressions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">functionC x y = if (x &gt; y) then x else y

functionC' x y = case x &gt; y of
    True -&gt; x
    False -&gt; y


ifEvenAdd2 n = if even n then (n+2) else n

ifEvenAdd2' n = case even n of
    True -&gt; n + 2
    False -&gt; n</code></pre>
</div>
</div>
<div class="paragraph">
<p>cover all cases (missing <code>EQ</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">nums x =
    case compare x 0 of
        LT -&gt; -1
        GT -&gt; 1
        EQ -&gt; 0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_7_higher_order_functions">7.7 Higher-order functions</h3>
<div class="sect3">
<h4 id="_intermission_exercises_14">Intermission: Exercises</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">dodgy :: Num a =&gt; a -&gt; a -&gt; a
dodgy x y = x + y * 10

oneIsOne :: Num a =&gt; a -&gt; a
oneIsOne = dodgy 1

oneIsTwo :: Num a =&gt; a -&gt; a
oneIsTwo = (flip dodgy) 2</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>dodgy 1 0 == 1</code></p>
</li>
<li>
<p><code>dodgy 1 1 == 11</code></p>
</li>
<li>
<p><code>dodgy 2 2 == 22</code></p>
</li>
<li>
<p><code>dodgy 1 2 == 21</code></p>
</li>
<li>
<p><code>dodgy 2 1 == 12</code></p>
</li>
<li>
<p><code>oneIsOne 1 == 11</code></p>
</li>
<li>
<p><code>oneIsOne 2 == 21</code></p>
</li>
<li>
<p><code>oneIsTwo 2 == 22</code></p>
</li>
<li>
<p><code>oneIsOne 3 == 31</code></p>
</li>
<li>
<p><code>oneIsTwo 3 == 23</code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_8_guards">7.8 Guards</h3>
<div class="sect3">
<h4 id="_intermission_exercises_15">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>otherwise</code> does not change behaviour</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">avgGrade :: (Fractional a, Ord a) =&gt; a -&gt; Char
avgGrade x
    | y &gt;= 0.9 = 'A'
    | y &gt;= 0.8 = 'B'
    | y &gt;= 0.7 = 'C'
    | y &gt;= 0.59 = 'D'
    | otherwise = 'F'
    where y = x / 100</code></pre>
</div>
</div>
</li>
<li>
<p>if <code>y &gt;= 0.7</code> is first, that is where <code>y &gt;= 0.9 = 'A'</code> was, then <code>y &gt;= 0.9</code> never becomes <code>True</code> as it is always caught by <code>y &gt;= 0.7</code>. Passing <code>90</code> returns <code>C</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">avgGrade :: (Fractional a, Ord a) =&gt; a -&gt; Char
avgGrade x
    | y &gt;= 0.7 = 'C'
    | y &gt;= 0.9 = 'A'
    | y &gt;= 0.8 = 'B'
    | y &gt;= 0.59 = 'D'
    | otherwise = 'F'
    where y = x / 100</code></pre>
</div>
</div>
</li>
<li>
<p>b) <code><strong>True</strong></code> when <code><strong>xs</strong></code> is a palidrome</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">pal xs
    | xs == reverse xs = True
    | otherwise = False</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>pal</strong></code> can take <code><strong>Eq a &#8658; [a]</strong></code> as an argument</p>
</li>
<li>
<p><code><strong>pal :: Eq a &#8658; [a] &#8594; Bool</strong></code></p>
</li>
<li>
<p>function bellow returns c) (argument is a positive or negative number)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">numbers x
    | x &lt; 0 = -1
    | x == 0 = 0
    | x &gt; 0 = 1</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>numbers :: (Num a, Ord a) &#8658; a</strong></code></p>
</li>
<li>
<p><code><strong>numbers :: (Num a, Num a1, Ord a1) &#8658; a1 &#8594; a</strong></code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_10_pointfree_style">7.10 Pointfree style</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Arith2 where
add :: Int -&gt; Int -&gt; Int
add x y = x + y

addPF :: Int -&gt; Int -&gt; Int
addPF = (+)

addOne :: Int -&gt; Int
addOne = \x -&gt; x + 1

addOnePF :: Int -&gt; Int
addOnePF = (+1)

main :: IO ()
main = do
    print (0 :: Int) -- 0
    print (add 1 0) -- 1
    print (addOne 0) -- 1
    print (addOnePF 0) -- 1
    print ((addOne . addOne) 0) -- 2
    print ((addOnePF . addOne) 0) -- 2
    print ((addOne . addOnePF) 0) -- 2
    print ((addOnePF . addOnePF) 0) -- 2
    print (negate (addOne 0)) -- -1
    print ((negate . addOne) 0) -- -1
    print ((addOne . addOne . addOne . negate . addOne) 0) -- 2</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_12_chapter_exercises">7.12 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_multiple_choice_3">Multiple choice</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>d) polymorphic function may resolve to values of different types, depending on inputs</p>
</li>
<li>
<p>b) <code><strong>Char &#8594; [String]</strong></code> for <code><strong>g . f</strong></code> where <code><strong>f :: Char &#8594; String</strong></code> and <code><strong>g :: String
&#8594; [String]</strong></code></p>
</li>
<li>
<p>d) <code><strong>(Ord a, Num a) &#8658; a &#8594; Bool</strong></code> for <code><strong>f :: Ord a &#8658; a &#8594; a &#8594; Bool</strong></code> applied to one numeric argument</p>
</li>
<li>
<p>b) is a higher-order function - <code><strong>(a &#8594; b) &#8594; c</strong></code></p>
</li>
<li>
<p>a) <code><strong>f True :: Bool</strong></code> where <code><strong>f</strong></code> is</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">f :: a -&gt; a
f x = x</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_let_s_write_code">Let’s write code</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>this function</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">tensDigit :: Integral a =&gt; a -&gt; a
tensDigit x = d
    where xLast = x `div` 10
          d     = xLast `mod` 10</code></pre>
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>using <code><strong>divMod</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">tensDigit :: Integral a =&gt; a -&gt; a
tensDigit x = d
    where xLast = fst $ divMod x 10
          d     = snd $ divMod xLast 10</code></pre>
</div>
</div>
</li>
<li>
<p>type signature is the same</p>
</li>
<li>
<p>hunderds</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">hunsD :: Integral a =&gt; a -&gt; a
hunsD x = d
    where x1 = fst $ divMod x 100
          d  = snd $ divMod x1 10</code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>function <code><strong>a &#8594; a &#8594; Bool &#8594; a</strong></code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>case expression</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">foldBool :: a -&gt; a -&gt; Bool -&gt; a
foldBool x y z =
    case z of
    True -&gt; x
    False -&gt; y</code></pre>
</div>
</div>
</li>
<li>
<p>guards</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">foldBool :: a -&gt; a -&gt; Bool -&gt; a
foldBool x y z
    | z = x
    | otherwise = y</code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>filled definition</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">g :: (a -&gt; b) -&gt; (a, c) -&gt; (b, c)
g f (x, y) = (f x, y)

-- *Main&gt; g show (1, 2)
-- ("1",2)</code></pre>
</div>
</div>
</li>
<li>
<p>look in the next point</p>
</li>
<li>
<p>pointfree version, <code><strong>roundTrip :: (Read a, Show a) &#8658; a &#8594; a</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Arith4 where

-- id :: a -&gt; a
-- id x = x

roundTrip :: (Show a, Read a) =&gt; a -&gt; a
roundTrip = read . show

main = do
    print (roundTrip 4)
    print (id 4)</code></pre>
</div>
</div>
</li>
<li>
<p>manually force <code><strong>Int</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Arith4 where

-- id :: a -&gt; a
-- id x = x

roundTrip :: (Show a, Read b) =&gt; a -&gt; b
roundTrip = read . show

main = do
    print ((roundTrip 4) :: Int)
    print (id 4)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_8_recursion">8 Recursion</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_8_2_factorial">8.2 Factorial</h3>
<div class="sect3">
<h4 id="_intermission_exercise">Intermission: Exercise</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">applyTimes 5 (+1) 5
(+1) (applyTimes (5 - 1) (+1) 5)
(+1) ((+1) (applyTimes (4 - 1) (+1) 5))
(+1) ((+1) ((+1) (applyTimes (3 - 1) (+1) 5)))
(+1) ((+1) ((+1) ((+1) (applyTimes (2 - 1) (+1) 5))))
(+1) ((+1) ((+1) ((+1) ((+1) (applyTimes (1 - 1) (+1) 5)))))
(+1) ((+1) ((+1) ((+1) ((+1) (5)))))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_8_6_chapter_exercises">8.6 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_review_of_types">Review of types</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>d) <code><strong>[[Bool]]</strong></code> is type of <code><strong>[[True, False], [True, True], [False, True]]</strong></code></p>
</li>
<li>
<p>b) <code><strong>[[3 == 3], [6 &gt; 5], [3 &lt; 4]]</strong></code> is the same type as <code><strong>[[True, False], [True, True], [False, True]]</strong></code></p>
</li>
<li>
<p>d) all of the above</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">func :: [a] -&gt; [a] -&gt; [a]
func x y = x ++ y</code></pre>
</div>
</div>
</li>
<li>
<p>b) <code><strong>func "Hello" "World"</strong></code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_reviewing_currying">Reviewing currying</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">cattyConny :: String -&gt; String -&gt; String
cattyConny x y = x ++ " mrow " ++ y

-- fill in the types
flippy :: String -&gt; String -&gt; String
flippy = flip cattyConny

appedCatty :: String -&gt; String
appedCatty = cattyConny "woops"

frappe :: String -&gt; String
frappe = flippy "haha"</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>value of <code><strong>appedCatty "woohoo!"</strong></code> is <code><strong>"woops mrow woohoo!"</strong></code></p>
</li>
<li>
<p>value of <code><strong>frappe "1"</strong></code> is <code><strong>"1 mrow haha"</strong></code></p>
</li>
<li>
<p>value of <code><strong>frappe (appedCatty "2")</strong></code> is <code><strong>woops mrow 2 mrow haha"</strong></code></p>
</li>
<li>
<p>value of <code><strong>appedCatty (frappe "blue")</strong> is `<strong>"woops mrow blue mrow haha"</strong></code></p>
</li>
<li>
<p>value of <code><strong>cattyConny (frappe "pink") (cattyConny "green" (appedCatty "blue"))</strong></code> is <code><strong>"pink mrow haha mrow green mrow woops mrow blue"</strong></code></p>
</li>
<li>
<p>value of <code><strong>cattyConny (flippy "Pugs" "are") "awesome"</strong></code> is <code><strong>"are mrow Pugs mrow awesome"</strong></code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_recursion">Recursion</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>step of <code><strong>dividedBy 15 2</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">dividedBy :: Integral a =&gt; a -&gt; a -&gt; (a, a)
dividedBy num denom = go num denom 0
    where go n d count
            | n &lt; d = (count, n)
            | otherwise = go (n - d) d (count + 1)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">dividedBy 15 2 =
go 15 2 0
| otherwise = go (15 - 2) 2 (0 + 1)
go 13 2 1
| otherwise = go (13 - 2) 2 (1 + 1)
go 11 2 2
| otherwise = go (11 - 2) 2 (2 + 1)
go 9 2 3
| otherwise = go (9 - 2) 2 (3 + 1)
go 7 2 4
| otherwise = go (7 - 2) 2 (4 + 1)
go 5 2 5
| otherwise = go (5 - 2) 2 (5 + 1)
go 3 2 6
| otherwise = go (3 - 2) 2 (6 + 1)
go 1 2 7
| 1 &lt; 2 = (7, 1)</code></pre>
</div>
</div>
</li>
<li>
<p>recursive sum function</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">recSum :: (Eq a, Num a) =&gt; a -&gt; a
recSum n = go n 0
    where go n acc
            | n == 0 = acc
            | otherwise = go (n - 1) (acc + n)</code></pre>
</div>
</div>
</li>
<li>
<p>recursive multiplication</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">recMul :: (Integral a) =&gt; a -&gt; a -&gt; a
recMul n m = go n m 0
    where go n m acc
            | m == 0 = acc
            | otherwise = go n (m - 1) (acc + n)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_fixing_dividedby">Fixing dividedBy</h4>
<div class="paragraph">
<p>Type of divideBy changed to match DividedResult.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data DividedResult =
      Result Integer
    | DividedByZero deriving Show

dividedBy :: Integer -&gt; Integer -&gt; DividedResult
dividedBy num denom
    | denom == 0 = DividedByZero
    | otherwise = go (abs num) (abs denom) 0 ((signum num) * (signum denom))
    where go n d count s
            | n &lt; d = Result (s * count)
            | otherwise = go (n - d) d (count + 1) s</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mccarthy_91_function">McCarthy 91 function</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">mc91 n
  | n &gt; 100 = n - 10
  | otherwise = (mc91 . mc91) (n + 11)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_numbers_into_words">Numbers into words</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module WordNumber where

import Data.List (intersperse)

digitToWord :: Int -&gt; String
digitToWord n =
    case n of
        0 -&gt; "zero"
        1 -&gt; "one"
        2 -&gt; "two"
        3 -&gt; "three"
        4 -&gt; "four"
        5 -&gt; "five"
        6 -&gt; "six"
        7 -&gt; "seven"
        8 -&gt; "eight"
        9 -&gt; "nine"

digits :: Int -&gt; [Int]
digits n = go n []
    where go a xs
            | a &gt; 9 = go (div a 10) ((mod a 10):xs)
            | otherwise = a:xs
            where

wordNumber :: Int -&gt; String
wordNumber = concat . intersperse "-" . map digitToWord . digits</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_lists">9 Lists</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_9_5_using_ranges_to_construct_lists">9.5 Using ranges to construct lists</h3>
<div class="sect3">
<h4 id="_exercise">Exercise</h4>
<div class="paragraph">
<p>The trick here was to use <code>fromEnum</code> and <code>toEnum</code> to get <code>Int</code> and avoid using <code>Ord</code> constrain in the signature. Got this insight from reading the <code>Enum</code> class source code - <a href="http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Enum.html#Enum" class="bare">http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Enum.html#Enum</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myEnumFromTo :: Enum a =&gt; a -&gt; a -&gt; [a]
myEnumFromTo x y
      | xi &gt; yi = []
      | otherwise = x : myEnumFromToi (succ xi) yi
      where xi = fromEnum x
            yi = fromEnum y
            myEnumFromToi a b
                | a &gt; b = []
                | otherwise = (toEnum a) : myEnumFromToi (succ a) b</code></pre>
</div>
</div>
<div class="paragraph">
<p>Writing my own <code>enumFromTo</code> for the following types is kind a of arbitrary since I did <code>myEnumFromTo</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">eftBool :: Bool -&gt; Bool -&gt; [Bool]
eftBool = undefined

eftOrd :: Ordering -&gt; Ordering -&gt; [Ordering]
eftOrd = undefined

eftInt :: Int -&gt; Int -&gt; [Int]
eftInt = undefined

eftChar :: Char -&gt; Char -&gt; [Char]
eftChar = undefined</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_6_extracting_portions_of_lists">9.6 Extracting portions of lists</h3>
<div class="sect3">
<h4 id="_intermission_exercises_16">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>make <code><strong>words</strong></code> function using <code><strong>dropWhile</strong></code> and <code><strong>takeWhile</strong></code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>first attempt</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myWords :: [Char] -&gt; [[Char]]
myWords [] = []
myWords a@(x:xs)
    | x == ' ' = myWords xs
    | otherwise = (takeWhile (\c -&gt; c /= ' ') a) : myWords (dropWhile (\c -&gt; c /= ' ') a)</code></pre>
</div>
</div>
</li>
<li>
<p>no need for lambdas</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myWords :: [Char] -&gt; [[Char]]
myWords [] = []
myWords a@(x:xs)
    | x == ' ' = myWords xs
    | otherwise = (takeWhile (/= ' ') a) : myWords (dropWhile (/= ' ') a)</code></pre>
</div>
</div>
</li>
<li>
<p>we can turn it into <code>case</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myWords :: [Char] -&gt; [[Char]]
myWords [] = []
myWords xs = case az of
                      [] -&gt; []
                      az -&gt; az : myWords (dropWhile (/= ' ') wsz)
               where wsz = (dropWhile (== ' ') xs)
                     az  = (takeWhile (/= ' ') wsz)</code></pre>
</div>
</div>
</li>
<li>
<p>simplyfy more</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myWords :: [Char] -&gt; [[Char]]
myWords [] = []
myWords xs = case dropWhile (== ' ') xs of
                      [] -&gt; []
                      az -&gt; w : myWords (dropWhile (/= ' ') az)
                            where w = takeWhile (/= ' ') az</code></pre>
</div>
</div>
</li>
<li>
<p>this one is very close to the version in <code>Prelude</code>, using <code>break</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myWords :: [Char] -&gt; [[Char]]
myWords [] = []
myWords xs = case dropWhile (== ' ') xs of
                      [] -&gt; []
                      az -&gt; w : myWords rest
                            where (w, rest) = break (== ' ') az</code></pre>
</div>
</div>
</li>
<li>
<p>and version from the book in the 9.14 Answers chapter. Pretty neat, did not think about matching the space as a pattern.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myWords :: String -&gt; [String]
myWords [] = []
myWords (' ':xs) = myWords xs
myWords xs =  takeWhile (/= ' ') xs:myWords (dropWhile (/= ' ') xs)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>break <code><strong>String</strong></code> on newlines</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module PoemLines where

firstSen = "Tyger Tyger, burning bright\n"
secondSen = "In the forests of the night\n"
thirdSen = "What immortal hand or eye\n"
fourthSen = "Could frame thy fearful symmetry?"
sentences = firstSen ++ secondSen ++ thirdSen ++ fourthSen

-- putStrLn sentences -- should print
-- Tyger Tyger, burning bright
-- In the forests of the night
-- What immortal hand or eye
-- Could frame thy fearful symmetry?

-- Implement this
myLines :: String -&gt; [String]
myLines [] = []
myLines xs = case dropWhile (== '\n') xs of
                      [] -&gt; []
                      az -&gt; w : myLines rest
                            where (w, rest) = break (== '\n') az

-- This is what we want 'myLines sentences' to equal
shouldEqual =
  [ "Tyger Tyger, burning bright"
  , "In the forests of the night"
  , "What immortal hand or eye"
  , "Could frame thy fearful symmetry?"
  ]

-- The main function here is a small test
-- to ensure you've written your function
-- correctly.
main :: IO ()
main =
  print $ "Are they equal? "
    ++ show (myLines sentences == shouldEqual)</code></pre>
</div>
</div>
</li>
<li>
<p>parametrized <code>myWords</code> and <code>myLines</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">separate :: [Char] -&gt; [[Char]]
separate [] = []
separate sep xs = case dropWhile (== sep) xs of
                      [] -&gt; []
                      az -&gt; w : myWords rest
                            where (w, rest) = break (== sep) az

myWords :: [Char] -&gt; [[Char]]
myWords = separate ' '


myLines :: String -&gt; [String]
myLines = separate '\n'</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_7_list_comprehensions">9.7 List comprehensions</h3>
<div class="sect3">
<h4 id="_adding_predicates">Adding predicates</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">mySqr = [x^2 | x &lt;- [1..10]]
-- result
[1,4,9,16,25,36,49,64,81,100]

[x | x &lt;- mySqr, rem x 2 == 0]
-- result
[4,16,36,64,100]

[(x, y) | x &lt;- mySqr, y &lt;- mySqr, x &lt; 50, y &gt; 50]
-- result
[(1,64),(1,81),(1,100),(4,64),(4,81),(4,100),(9,64),(9,81),(9,100),(16,64),(16,81),(16,100),(25,64),(25,81),(25,100),(36,64),(36,81),(36,100),(49,64),(49,81),(49,100)]

take 5 [(x, y) | x &lt;- mySqr, y &lt;- mySqr, x &lt; 50, y &gt; 50]
-- result
[(1,64),(1,81),(1,100),(4,64),(4,81)]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_list_comprehensions_with_strings">List comprehensions with Strings</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">Prelude&gt; let mySqr = [x^2 | x &lt;- [1..5]]
Prelude&gt; let myCube = [y^3 | y &lt;- [1..5]]</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>tuples of <code><strong>mySqr</strong></code> and <code><strong>myCube</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">[(x, y) | x &lt;- mySqr, y &lt;- myCube]
-- [(1,1),(1,8),(1,27),(1,64),(1,125),(4,1),(4,8),(4,27),(4,64),(4,125),(9,1),(9,8),(9,27),(9,64),(9,125),(16,1),(16,8),(16,27),(16,64),(16,125),(25,1),(25,8),(25,27),(25,64),(25,125)]</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>x</strong></code> and <code><strong>y</strong></code> from previous point that are less than 50</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">[(x, y) | x &lt;- mySqr, y &lt;- myCube, x &lt; 50, y &lt; 50]
-- [(1,1),(1,8),(1,27),(4,1),(4,8),(4,27),(9,1),(9,8),(9,27),(16,1),(16,8),(16,27),(25,1),(25,8),(25,27)]</code></pre>
</div>
</div>
</li>
<li>
<p>number of tuples from previuos point</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">length [(x, y) | x &lt;- mySqr, y &lt;- myCube, x &lt; 50, y &lt; 50]
-- 15</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_8_spines_and_non_strict_evaluation">9.8 Spines and non-strict evaluation</h3>
<div class="sect3">
<h4 id="_intermission_exercises_17">Intermission: Exercises</h4>

</div>
<div class="sect3">
<h4 id="_will_it_blow_up">Will it blow up?</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>yes, it gets evaluated to <code><strong>undefined</strong></code> because of <code>x^y</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">[x^y | x &lt;- [1..5], y &lt;- [2, undefined]]</code></pre>
</div>
</div>
</li>
<li>
<p>no, only first element of list get evaluated</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 1 $ [x^y | x &lt;- [1..5], y &lt;- [2, undefined]]</code></pre>
</div>
</div>
</li>
<li>
<p>yes, sum breaks on <code><strong>undefined</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">sum [1, undefined, 3]</code></pre>
</div>
</div>
</li>
<li>
<p>no, <code><strong>length</strong></code> ignores values</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">length [1, 2, undefined]</code></pre>
</div>
</div>
</li>
<li>
<p>yes, <code><strong>undefined</strong></code> is part of spine</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">length $ [1, 2, 3] ++ undefined</code></pre>
</div>
</div>
</li>
<li>
<p>no, evaluates to second list element</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 1 $ filter even [1, 2, 3, undefined]</code></pre>
</div>
</div>
</li>
<li>
<p>yes, <code><strong>take 1</strong></code> forces <code><strong>filter</strong></code> to evaluate until <code><strong>undefined</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 1 $ filter even [1, 3, undefined]</code></pre>
</div>
</div>
</li>
<li>
<p>no, only first element evaluated</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 1 $ filter odd [1, 3, undefined]</code></pre>
</div>
</div>
</li>
<li>
<p>no, only first two elemnts evaluated</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 2 $ filter odd [1, 3, undefined]</code></pre>
</div>
</div>
</li>
<li>
<p>yes, trird element is <code><strong>undefined</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 3 $ filter odd [1, 3, undefined]</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_is_it_in_normal_form">Is it in normal form?</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
not sure
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>WHHNF</code> and <code>NF</code>, all evaluated <code><strong>[1, 2, 3, 4, 5]</strong></code></p>
</li>
<li>
<p><code>WHNF</code> because of <code><strong>_</strong></code> in <code><strong>1 : 2 : 3 : 4 : _</strong></code></p>
</li>
<li>
<p><code>neither</code>, not data constructor <code><strong>enumFromTo 1 10</strong></code></p>
</li>
<li>
<p><code>neither</code>, not data constructor <code><strong>length [1, 2, 3, 4, 5]</strong></code></p>
</li>
<li>
<p><code>neither</code>, not data constructor <code><strong>sum (enumFromTo 1 10)</strong></code></p>
</li>
<li>
<p><code>neither</code>, not data constructor <code><strong>['a'..'m'] ++ ['n'..'z']</strong></code></p>
</li>
<li>
<p><code>WHFN</code>, not all evaluated <code><strong>(_, 'b')</strong></code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_9_transforming_lists_of_values">9.9 Transforming lists of values</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>will return bottom, <code>take 1</code> evaluates <code>undefined</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 1 $ map (+1) [undefined, 2, 3]</code></pre>
</div>
</div>
</li>
<li>
<p>returns <code>2</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 1 $ map (+1) [1, undefined, 3]</code></pre>
</div>
</div>
</li>
<li>
<p>bottom, second element is <code>undefined</code> and is evaluated by <code>take 2</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">take 2 $ map (+1) [1, undefined, 3]</code></pre>
</div>
</div>
</li>
<li>
<p>function transforms <code>String</code> into a list of <code>Bool</code> depending if character is vovel, type in code</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">itIsMystery :: String -&gt; [Bool]
itIsMystery xs = map (\x -&gt; elem x "aeiou") xs</code></pre>
</div>
</div>
</li>
<li>
<p>results</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code><strong>map (^2) [1..10]</strong></code> evaluates to <code>[1,4,9,16,25,36,49,64,81,100]</code></p>
</li>
<li>
<p><code><strong>map minimum [[1..10], [10..20], [20..30]]</strong></code> evaluates to <code>[1,10,20]</code></p>
</li>
<li>
<p><code><strong>map sum [[1..5], [1..5], [1..5]]</strong></code> evaluates to <code>[15,15,15]</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>rewrite</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Bool (bool)

foldBool :: [Integer] -&gt; [Integer]
foldBool = map (\x -&gt; bool x (-x) (x == 3))</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_9_10_filtering_lists_of_values">9.10 Filtering lists of values</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><strong>filter (\x &#8594; (rem x 3) == 0) [1..30]</strong></code></p>
</li>
<li>
<p><code><strong>(length . filter (\ x &#8594; (rem x 3) == 0)) [1 .. 30]</code></strong></p>
</li>
<li>
<p><code><strong>myFilter = filter (\x &#8594; not (elem x ["the", "a", "an"])) . words</strong></code></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_9_11_zipping_lists">9.11 Zipping lists</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>zip</code> implementation, using a little trick that any empty list falls through to the all-catch pattern. Could be written on more lines explicitly matching the empty lists.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">zip' :: [a] -&gt; [b] -&gt; [(a, b)]
zip' (x:xs) (y:ys) = (x, y) : zip' xs ys
zip' _ _ = []</code></pre>
</div>
</div>
</li>
<li>
<p><code>zipWith</code> implementation</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
zipWith' _ _ _ = []</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_9_12_chapter_exercises">9.12 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_data_char">Data.Char</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><strong>isUpper :: Char &#8594; Bool</strong></code>, <code><strong>toUpper :: Char &#8594; Char</strong></code></p>
</li>
<li>
<p><code><strong>let fUp = filter (\x &#8594; isUpper x)</strong></code></p>
</li>
<li>
<p>capitalize first letter</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (toUpper)

myCap :: [Char] -&gt; [Char]
myCap (x:xs) = toUpper x : xs
myCap _ = ""</code></pre>
</div>
</div>
</li>
<li>
<p>capitalize all letters</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (toUpper)

myCap :: [Char] -&gt; [Char]
myCap (x:xs) = toUpper x : myCap xs
myCap "" = ""</code></pre>
</div>
</div>
</li>
<li>
<p>capitalize and return first letter using <code><strong>head</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (toUpper)

fstCap :: [Char] -&gt; Char
fstCap xs = toUpper $ head xs</code></pre>
</div>
</div>
</li>
<li>
<p>previous function as composed and then pointfree</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (toUpper)

fstCapCom :: [Char] -&gt; Char
fstCapCom xs = (toUpper . head) xs

fstCapPf :: [Char] -&gt; Char
fstCapPf = toUpper . head</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ciphers">Ciphers</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (ord, chr, isAlpha)

caesar :: String -&gt; Int -&gt; String
caesar [] _ = []
caesar (x:xs) n
  | isAlpha x = docyp x n (+) : caesar xs n
  | otherwise = x : caesar xs n


unCaesar :: String -&gt; Int -&gt; String
unCaesar [] _ = []
unCaesar (x:xs) n
  | isAlpha x = docyp x n (-) : unCaesar xs n
  | otherwise = x: unCaesar xs n

docyp :: Char -&gt; Int -&gt; (Int -&gt; Int -&gt; Int) -&gt; Char
docyp x n f = chr $ f (ord x - base) n `mod` r + base
  where base = ord 'a'
        r = 26

t = "abc xyz"
shift = 5

cipherOk = (unCaesar (caesar t shift) shift) == t</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_writing_your_own_standard_functions">Writing your own standard functions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><strong>myOr</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myOr :: [Bool] -&gt; Bool
myOr [] = False
myOr (x:xs) = if x == True then True else myOr xs

myOr' :: [Bool] -&gt; Bool
myOr' [] = False
myOr' (x:xs)
    | x = x
    | otherwise = myOr xs</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>myAny</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myAny :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
myAny f [] = False
myAny f (x:xs) = if f x == True then True else myAny f xs

myAny' :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
myAny' _ [] = False
myAny' f (x:xs)
    | f x = True
    | otherwise = myAny f xs</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>myElem</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myElem :: Eq a =&gt; a -&gt; [a] -&gt; Bool
myElem _ [] = False
myElem a (x:xs) = if a == x then True else myElem a xs

myElem' :: Eq a =&gt; a -&gt; [a] -&gt; Bool
myElem' _ [] = False
myElem' a (x:xs)
    | a == x = True
    | otherwise = myElem a xs

myElem'' :: Eq a =&gt; a -&gt; [a] -&gt; Bool
myElem'' _ [] = False
myElem'' a xs = any (\x -&gt; a == x) xs

myElem''' :: Eq a =&gt; a -&gt; [a] -&gt; Bool
myElem''' _ [] = False
myElem''' a xs = any (a ==) xs</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>myReverse</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myReverse :: [a] -&gt; [a]
myReverse xs = go [] xs
  where go ys [] = ys
        go ys (x:xs) = go (x : ys) xs</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>squish</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">squish :: [[a]] -&gt; [a]
squish [] = []
squish (x:xs) = x ++ squish xs</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>squishMap</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">squishMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]
squishMap _ [] = []
squishMap f (x:xs) = f x ++ squishMap f xs</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>squishAgain</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">squishMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]
squishMap _ [] = []
squishMap f (x:xs) = f x ++ squishMap f xs

squishAgain :: [[a]] -&gt; [a]
squishAgain xs = squishMap (\x -&gt; x) xs

squishAgain' :: [[a]] -&gt; [a]
squishAgain' xs = squishMap id xs</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>myMaximumBy</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myMaximumBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; a
myMaximumBy _ [] = undefined
myMaximumBy _ (x:[]) = x
myMaximumBy f (x:xs) = go f x xs
  where go f b (x:xs)
          | f b x == GT = go f b xs
          | otherwise = go f x xs
        go f b [] = b</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>myMinimumBy</strong></code>, <code><strong>myMaximum</strong></code>, <code><strong>myMinimum</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myMaximumBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; a
myMaximumBy f (x:xs) = go f x xs
  where go f b (x:xs)
          | f b x == GT = go f b xs
          | otherwise = go f x xs
        go f b [] = b

myMinimumBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; a
myMinimumBy f (x:xs) = go f x xs
  where go f b (x:xs)
          | f b x == LT = go f b xs
          | otherwise = go f x xs
        go f b [] = b

myMaximum :: (Ord a) =&gt; [a] -&gt; a
myMaximum xs = myMaximumBy (\a b -&gt; compare a b) xs

myMinimum :: (Ord a) =&gt; [a] -&gt; a
myMinimum xs = myMinimumBy (\a b -&gt; compare a b) xs</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_10_folding_lists">10 Folding lists</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_10_5_fold_left">10.5 Fold left</h3>
<div class="sect3">
<h4 id="_intermission_exercises_18">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>b) and c) have the same result, a) has error</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">foldr (*) 1 [1..5]
-- b)
foldl (flip (*)) 1 [1..5]
-- c)
foldl (*) 1 [1..5]</code></pre>
</div>
</div>
</li>
<li>
<p>evaluation steps of <code>foldl (flip (*)) 1 [1..3]</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">foldl (flip (*)) 1 [1..3]
 = foldl (flip (*)) (1 * 1) [2,3]
 = foldl (flip (*)) (2 * (1 * 1)) [3]
 = foldl (flip (*)) (3 * (2 * (1 * 1))) []
 = (3 * (2 * (1 * 1)))</code></pre>
</div>
</div>
</li>
<li>
<p>c) one difference between <code><strong>foldr</strong></code> and <code><strong>foldl</strong></code> is that <code><strong>foldr</strong></code>, but not <code><strong>foldl</strong></code>, associates to the right</p>
</li>
<li>
<p>a) folds are catamorphisms, they are used to reduce structure</p>
</li>
<li>
<p>fixed functions</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>foldr (++) "" ["woot", "WOOT", "woot"]</code></p>
</li>
<li>
<p><code>foldr max "" ["fear","is","the","little","death"]</code></p>
</li>
<li>
<p><code>foldr (&amp;&amp;) True [False, True]</code></p>
</li>
<li>
<p><code>foldr (||) True [False, True]</code> always return <code>True</code></p>
</li>
<li>
<p><code>foldl (\x y &#8594; x ++ show y) "" [1..5]</code></p>
</li>
<li>
<p><code>foldr (flip const) 'a' [1..5]</code></p>
</li>
<li>
<p><code>foldr (flip const) 0 "tacos"</code></p>
</li>
<li>
<p><code>foldl const 0 "burritos"</code></p>
</li>
<li>
<p><code>foldl const 'z' [1..5]</code></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_10_6_how_to_write_fold_functions">10.6 How to write fold functions</h3>
<div class="sect3">
<h4 id="_intermission_exercises_19">Intermission: Exercises</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Time

data DatabaseItem = DbString String
                  | DbNumber Integer
                  | DbDate UTCTime
                  deriving (Eq, Ord, Show)

theDatabase :: [DatabaseItem]
theDatabase =
  [ DbDate (UTCTime
            (fromGregorian 1911 5 1)
            (secondsToDiffTime 34123))
  , DbNumber 9001
  , DbString "Hello, world!"
  , DbDate (UTCTime
              (fromGregorian 1921 5 1)
              (secondsToDiffTime 34123))
  ]

-- tried the same with filter and map, not woth it. fold is the way
filterDbDate :: [DatabaseItem] -&gt; [UTCTime]
filterDbDate = foldr f []
  where f (DbDate a) b = a : b
        f _ b = b

filterDbNumber :: [DatabaseItem] -&gt; [Integer]
filterDbNumber = foldr f []
  where f (DbNumber a) b = a : b
        f _ b = b

-- I need a base, not ideal, but UTCTime long in the past will do now
mostRecent :: [DatabaseItem] -&gt; UTCTime
mostRecent = foldr f (UTCTime (fromGregorian 0 1 1) (secondsToDiffTime 0))
  where f (DbDate a) b
          | a &gt; b = a
          | otherwise = b
        f _ b = b

sumDb :: [DatabaseItem] -&gt; Integer
sumDb = foldr f 0
  where f (DbNumber a) b = a + b
        f _ b = b

avgDb :: [DatabaseItem] -&gt; Double
avgDb = average . filterDbNumber
  where average [] = 0
        average xs = fromIntegral (sum xs) / fromIntegral (length xs)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_10_9_scans">10.9 Scans</h3>
<div class="paragraph">
<p>The <code>fibs</code> using <code>scanl</code> is a little bit of a mind bender at the beginning. I wrote out the evaluation <a href="https://gist.github.com/lukleh/67cf0a78205d3f6bd2d9" class="bare">https://gist.github.com/lukleh/67cf0a78205d3f6bd2d9</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">fibs = 1 : scanl (+) 1 fibs

-- 1)
fibs20 = take 20 fibs

-- 2)
fibsLT100 = takeWhile (&lt; 100) fibs

-- 3)
factorials = scanl (*) 1 [1..]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_10_10_chapter_exercises">10.10 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_warm_up_and_review">Warm-up and review</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>tuples</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">stops = "pbtdkg"
vowels = "aeiou"

-- a)
svs stops vowels = [(s,v,s') | s &lt;- stops, v &lt;- vowels, s' &lt;- stops]

-- b)
svsP stops vowels = [(s,v,s') | s &lt;- stops, v &lt;- vowels, s' &lt;- stops, s == 'p']

-- c)
nouns = ["apple", "banana", "orange"]
verbs = ["turns", "peals", "eats"]
nvn nouns verbs = [(n,v,n') | n &lt;- nouns, v &lt;- verbs, n' &lt;- nouns]</code></pre>
</div>
</div>
</li>
<li>
<p>following function return average size (round to integer) of word in a sentece (string)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">seekritFunc ::  String -&gt; Int
seekritFunc x =
  div (sum (map length (words x)))
      (length (words x))</code></pre>
</div>
</div>
</li>
<li>
<p>returing <code><strong>Fractional</strong></code> values</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">seekritFunc ::  Fractional a =&gt; String -&gt; a
seekritFunc x =
  fromIntegral (sum (map length (words x))) / fromIntegral (length (words x))</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_rewriting_functions_using_folds">Rewriting functions using folds</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>myOr</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myOr :: [Bool] -&gt; Bool
myOr = foldr (||) False</code></pre>
</div>
</div>
</li>
<li>
<p>myAny</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myAny f = foldr (\ x y -&gt; f x || y) False</code></pre>
</div>
</div>
</li>
<li>
<p>myElem</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myElem :: Eq a =&gt; a -&gt; [a] -&gt; Bool
myElem a = foldr (\ x y -&gt; (a == x) || y) False</code></pre>
</div>
</div>
</li>
<li>
<p>myReverse</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myReverse :: [a] -&gt; [a]
myReverse = foldl (flip (:)) []</code></pre>
</div>
</div>
</li>
<li>
<p>myMap</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]
myMap f xs = foldr (\a b -&gt; f a : b) [] xs

-- answer from the book is nicer
myMap' f = foldr ((:) . f) []</code></pre>
</div>
</div>
</li>
<li>
<p>myFilter</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myFilter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
myFilter pr = foldr f []
  where f a b
          | pr a = a : b
          | otherwise = b</code></pre>
</div>
</div>
</li>
<li>
<p>squish</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">squish :: [[a]] -&gt; [a]
squish = foldr (++) []</code></pre>
</div>
</div>
</li>
<li>
<p>squishMap</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">squishMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]
squishMap f = foldr (\a b -&gt; f a ++ b) []

-- again, answer from the book is nicer
squishMap' f = foldr ((++) . f) []</code></pre>
</div>
</div>
</li>
<li>
<p>squishAgain using squishMap</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">squishMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]
squishMap f = foldr (\a b -&gt; f a ++ b) []

squishAgain :: [[a]] -&gt; [a]
squishAgain = squishMap id</code></pre>
</div>
</div>
</li>
<li>
<p>myMaximumBy</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myMaximumBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; a
myMaximumBy _ []     = undefined
myMaximumBy _ [x]    = x
myMaximumBy f (x:xs) = foldl fo x xs
  where fo a b
          | f a b == GT = a
          | otherwise = b</code></pre>
</div>
</div>
</li>
<li>
<p>myMinimumBy</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myMinimumBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; a
myMinimumBy _ []     = undefined
myMinimumBy _ [x]    = x
myMinimumBy f (x:xs) = foldl fo x xs
  where fo a b
          | f a b == LT = a
          | otherwise = b</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_algebraic_datatypes">11 Algebraic datatypes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_11_4_data_constructors_and_values">11.4 Data constructors and values</h3>
<div class="paragraph">
<p>For data types</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data DogueDeBordeaux doge = DogueDeBordeaux doge

data Doggies a =
      Husky a
    | Mastiff a
    deriving (Eq, Show)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><strong>Doggies</strong></code> is type constructor</p>
</li>
<li>
<p>kind of <code><strong>Doggies</strong></code> is <code><strong>* -> *</strong></code></p>
</li>
<li>
<p>kind of <code><strong>Doggies String</strong></code> is <code><strong>*</strong></code></p>
</li>
<li>
<p>type of <code><strong>Husky 10</strong></code> is <code><strong>Num a &#8658; Doggies a</strong></code></p>
</li>
<li>
<p>type of <code><strong>Husky (10 :: Integer)</strong></code> is <code><strong>Doggies Integer</strong></code></p>
</li>
<li>
<p>type of <code><strong>Mastiff "Scooby Doo"</strong></code> is <code><strong>Doggies String</strong></code></p>
</li>
<li>
<p><code><strong>DogueDeBordeaux</strong></code> is both type and data constructor</p>
</li>
<li>
<p>type of <code><strong>DogueDeBordeaux</strong></code> is <code><strong>doge &#8594; DogueDeBordeaux doge</strong></code></p>
</li>
<li>
<p>type of <code><strong>DogueDeBordeaux "doggie!"</strong></code> is <code><strong>DogueDeBordeaux String</strong></code></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_11_5_what_s_a_type_and_what_s_data">11.5 What’s a type and what’s data?</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Price = Price Integer deriving (Eq, Show)

data Manufacturer =
    Mini
  | Mazda
  | Tata
  deriving (Eq, Show)

data Airline =
    PapuAir
  | CatapultsR'Us
  | TakeYourChancesUnited
  deriving (Eq, Show)

data Vehicle =
    Car Manufacturer Price
  | Plane Airline
  deriving (Eq, Show)

myCar = Car Mini (Price 14000)
urCar = Car Mazda (Price 20000)
clownCar = Car Tata (Price 7000)
doge = Plane PapuAir</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>type of <code><strong>myCar</strong></code> is <code><strong>Vehicle</strong></code></p>
</li>
<li>
<p>define functions</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">isCar :: Vehicle -&gt; Bool
isCar (Car _ _ ) = True
isCar _ = False

isPlane :: Vehicle -&gt; Bool
isPlane (Plane _) = True
isPlane _ = False

areCars :: [Vehicle] -&gt; [Bool]
areCars = map isCar</code></pre>
</div>
</div>
</li>
<li>
<p>define function (error on non Car)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">getManu :: Vehicle -&gt; Manufacturer
getManu (Car m _)= m</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>Plane Airline</strong></code> for <code><strong>getManu</strong></code> error is <code>Non-exhaustive patterns in function getManu</code>. You can add all catching pattern, but it would have to end up in error anyway, as there is no <code>Manufacturer</code> for non-Car value.</p>
</li>
<li>
<p>add size for <code><strong>Plane</strong></code>, can be done similary as <code><strong>Price</strong></code> with <code><strong>Double</strong></code> instead of <code><strong>Integer</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Price = Price Integer deriving (Eq, Show)
data Size = Size Double deriving (Eq, Show)

data Manufacturer =
    Mini
  | Mazda
  | Tata
  deriving (Eq, Show)

data Airline =
    PapuAir
  | CatapultsR'Us
  | TakeYourChancesUnited
  deriving (Eq, Show)

data Vehicle =
    Car Manufacturer Price
  | Plane Airline Size
  deriving (Eq, Show)

myCar = Car Mini (Price 14000)
urCar = Car Mazda (Price 20000)
clownCar = Car Tata (Price 7000)
doge = Plane PapuAir (Size 100)

isPlane :: Vehicle -&gt; Bool
isPlane (Plane _ _) = True
isPlane _ = False</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_11_7_what_makes_these_datatypes_algebraic">11.7 What makes these datatypes algebraic?</h3>
<div class="sect3">
<h4 id="_intermission_exercises_20">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>cardinality 1 <code><strong>data PugType = PugData</strong></code></p>
</li>
<li>
<p>cardinality 3</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Airline =
      PapuAir
    | CatapultsR'Us
    | TakeYourChancesUnited</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>Int16</strong></code> has cardinality <code>65535</code></p>
</li>
<li>
<p><code><strong>Int</strong></code> is instance of <code><strong>Bounded</strong></code>, therefore cardinality can be determined. <code><strong>Integer</strong></code> does not have bounds</p>
</li>
<li>
<p><code><strong>Int8</strong></code> has <code>256</code> values, which corresponds to <code>2 ^ 8 = 256</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_simple_datatypes_with_nullary_data_constructors">Simple datatypes with nullary data constructors</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Example = MakeExample deriving Show</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><strong>MakeExample</strong></code> has type <code><strong>Example</strong></code>. <code><strong>:t Example</strong></code> gives error <code>Not in scope: data constructor ‘Example’</code></p>
</li>
<li>
<p><code><strong>:i Example</strong></code> shows that it is instance of <code><strong>Show</strong></code> typeclass</p>
</li>
<li>
<p><code><strong>:t MakeExample</strong></code> gives <code>Int &#8594; Example</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_newtype">newtype</h4>
<div class="paragraph">
<p>type synonym does not work</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">class TooMany a where
  tooMany :: a -&gt; Bool

instance TooMany Int where
  tooMany n = n &gt; 42

newtype Goats = Goats Int deriving Show

instance TooMany Goats where
  tooMany (Goats n) = n &gt; 43

-- error
-- Illegal instance declaration for ‘TooMany GoatInt’
--       (All instance types must be of the form (T t1 ... tn)
--        where T is not a synonym.
--        Use TypeSynonymInstances if you want to disable this.)
--     In the instance declaration for ‘TooMany GoatInt’
--
-- type GoatInt = Int
-- instance TooMany GoatInt where
--   tooMany n = n &gt; 44</code></pre>
</div>
</div>
<div class="paragraph">
<p>GHC pragma <code>GeneralizedNewtypeDeriving</code> works for <code>tooMany (Goats 45)</code> even without declaring an instance. Reusing <code>Int</code> instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">{-# LANGUAGE GeneralizedNewtypeDeriving #-}

class TooMany a where
  tooMany :: a -&gt; Bool

instance TooMany Int where
  tooMany n = n &gt; 42

newtype Goats = Goats Int deriving (Eq, Show, TooMany)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_intermission_exercises_21">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>without <code><strong>newtype</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">{-# LANGUAGE FlexibleInstances #-}

class TooMany a where
  tooMany :: a -&gt; Bool

instance TooMany (Int, String) where
  tooMany (n, s) = n &gt; 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code><strong>newtype</strong></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">class TooMany a where
  tooMany :: a -&gt; Bool

newtype Goats = Goats (Int, String) deriving Show

instance TooMany Goats where
  tooMany (Goats (n, s)) = n &gt; 42</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>TooMany</strong></code> instance for <code><strong>(Int, Int)</strong></code>, sum the values</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">class TooMany a where
  tooMany :: a -&gt; Bool

newtype Goats = Goats (Int, Int) deriving Show

instance TooMany Goats where
  tooMany (Goats (n, n')) = (n + n') &gt; 42</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>TooMany</strong></code> instance for <code><strong>(Num a, TooMany a) &#8658; (a, a)</strong></code></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>TooMany a</code> as class constraint means we know what to do with <code>toomany x</code>. If we use <code>(n + n') &gt; 42</code> as the implementation, then we get error as there is no <code>Ord</code> for <code>TooMany</code>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">{-# LANGUAGE FlexibleInstances #-}

class TooMany a where
  tooMany :: a -&gt; Bool

instance TooMany Int where
  tooMany n = n &gt; 42

instance (Num a, TooMany a) =&gt; TooMany (a, a) where
  tooMany (n, n') =  tooMany (n + n')</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
All of the following breaks. Ambiguous type or could not deduce class constraint.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">{-# LANGUAGE FlexibleInstances #-}

class TooMany a where
  tooMany :: a -&gt; Bool

instance (Num a, Integral a, TooMany a) =&gt; TooMany (a, a) where
  tooMany (n, n') = odd (n + n')


instance (Num a, Integral a) =&gt; TooMany (a, a) where
  tooMany (n, n') = odd (n + n')


instance (Num a, Ord a, TooMany a) =&gt; TooMany (a, a) where
  tooMany (n, n') = (n + n') &gt; 42


instance (Num a, TooMany a) =&gt; TooMany (a, a) where
  tooMany (n, n') = (n + n') &gt; 42


instance Num a =&gt; TooMany (a, a) where
  tooMany (n, n') = (n + n') &gt; 42


instance (Num a, Ord a) =&gt; TooMany (a, a) where
  tooMany (n, n') = (n + n') &gt; 42</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_8_sum_types">11.8 Sum types</h3>
<div class="sect3">
<h4 id="_intermission_exercises_22">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>cardinality is 4. <code>Bool</code> is 2 and sum type adds</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data BigSmall =
      Big Bool
    | Small Bool
    deriving (Eq, Show)</code></pre>
</div>
</div>
</li>
<li>
<p>cardinality is 258. <code>Int8</code> is 256, <code>Bool</code> is 2, sum type adds. <code>let myNumba = Numba (-128)</code> breaks, details in <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html" class="bare">https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html</a> <code>NegativeLiterals</code>. Number out of <code>Int8</code> range gives error <code>Literal 1000 is out of the Int8 range -128..127</code> for <code>1000 :: Int8</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Int

data NumberOrBool =
      Numba Int8
    | BoolyBool Bool
    deriving (Eq, Show)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_9_product_types">11.9 Product types</h3>
<div class="sect3">
<h4 id="_intermission_jammin_exercises">Intermission: Jammin Exercises</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">-- 1.
module Jammin where

-- 8.
import Data.List (sortBy, groupBy,maximumBy)

data Fruit =
    Peach
  | Plum
  | Apple
  | Blackberry
  deriving (Eq, Show, Ord) -- 4.

data JamJars =
  Jam {fruit :: Fruit, jars :: Int}  -- 2.
  deriving (Eq, Show, Ord) -- 4.

-- 3. cardinality is 4 (Fruit) * cardinality of Int

row1 = Jam {fruit = Plum, jars = 4} -- construct using record syntax
row2 = Jam Peach 1
row3 = Jam Plum 4
row4 = Jam Blackberry 8
row5 = Jam Apple 4
row6 = Jam Apple 7
allJam = [row1, row2, row3, row4, row5, row6]

-- 5.
rowJars :: [JamJars] -&gt; [Int]
rowJars = map jars

-- 6.
jarsCount :: [JamJars] -&gt; Int
jarsCount = sum . rowJars

-- 7.
mostRow :: [JamJars] -&gt; JamJars
mostRow = maximumBy (\j1 j2 -&gt; compare (jars j1) (jars j2))

-- 9.
compareKind :: JamJars -&gt; JamJars -&gt; Ordering
compareKind (Jam k _) (Jam k' _) = compare k k'
sortJams :: [JamJars] -&gt; [JamJars]
sortJams = sortBy compareKind

-- 10.
groupJam :: [JamJars] -&gt; [[JamJars]]
groupJam = groupBy (\j1 j2 -&gt; fruit j1 == fruit j2) . sortJams

-- different way
-- import Data.Function (on)
-- groupJam = groupBy (==) on (fruit) . sortJams</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_10_normal_form">11.10 Normal form</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Fiction = Fiction deriving Show
data Nonfiction = Nonfiction deriving Show
data BookType = FictionBook Fiction
            | NonfictionBook Nonfiction
            deriving Show

type AuthorName = String
data Author = Author (AuthorName, BookType)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><strong>BookType</strong></code> gone</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">type AuthorName = String
data Author =
      Fiction AuthorName
    | Nonfiction AuthorName
    deriving (Eq, Show)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_exercises">Exercises</h4>
<div class="paragraph">
<p>this code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data FlowerType = Gardenia
                | Daisy
                | Rose
                | Lilac
                deriving Show

type Gardener = String

data Garden =
    Garden Gardener FlowerType
    deriving Show</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Garden</code> in normal form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">type Gardener = String

data Garden =
      Gardenia Gardener
    | Daisy Gardener
    | Rose Gardener
    | Lilac Gardener
    deriving Show</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_11_constructing_and_deconstructing_values">11.11 Constructing and deconstructing values</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data OperatingSystem = GnuPlusLinux
                      | OpenBSDPlusNevermindJustBSDStill
                      | Mac
                      | Windows
                      deriving (Eq, Show)

data ProgrammingLanguage =  Haskell
                            | Agda
                            | Idris
                            | PureScript
                            deriving (Eq, Show)

data Programmer = Programmer { os :: OperatingSystem
                             , lang :: ProgrammingLanguage }
                             deriving (Eq, Show)

allOperatingSystems :: [OperatingSystem]
allOperatingSystems =
    [ GnuPlusLinux
    , OpenBSDPlusNevermindJustBSDStill
    , Mac
    , Windows
    ]

allLanguages :: [ProgrammingLanguage]
allLanguages = [Haskell, Agda, Idris, PureScript]

allProgrammers :: [Programmer]
allProgrammers = [Programmer {os = o, lang = l} | o &lt;- allOperatingSystems, l &lt;- allLanguages]

-- this should be True to be correct
passed = length allProgrammers == length allOperatingSystems * length allLanguages</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_12_function_type_is_exponential">11.12 Function type is exponential</h3>
<div class="sect3">
<h4 id="_exponentiation_in_what_order">Exponentiation in what order?</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Quantum =
    Yes
  | No
  | Both
  deriving (Eq, Show)


convert :: Quantum -&gt; Bool

convert1 Yes = True
convert1 No = True
convert1 Both = True

convert2 Yes = True
convert2 No = True
convert2 Both = False

convert3 Yes = True
convert3 No = False
convert3 Both = False

convert4 Yes = False
convert4 No = False
convert4 Both = False

convert5 Yes = False
convert5 No = False
convert5 Both = True

convert6 Yes = False
convert6 No = True
convert6 Both = True

convert7 Yes = False
convert7 No = True
convert7 Both = False

convert8 Yes = True
convert8 No = False
convert8 Both = True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_intermission_exercises_23">Intermission: Exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>4 + 4 = 8</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Quad =
      One
    | Two
    | Three
    | Four
    deriving (Eq, Show)
eQuad :: Either Quad Quad
eQuad = ???</code></pre>
</div>
</div>
</li>
<li>
<p><code>4 * 4 = 16</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">prodQuad :: (Quad, Quad)</code></pre>
</div>
</div>
</li>
<li>
<p><code>4 ^ 4 = 256</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">funcQuad :: Quad -&gt; Quad</code></pre>
</div>
</div>
</li>
<li>
<p><code>2 * 2 * 2 = 16</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">prodTBool :: (Bool, Bool, Bool)</code></pre>
</div>
</div>
</li>
<li>
<p><code>(2 ^ 2) ^ 2 = 16</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">gTwo :: Bool -&gt; Bool -&gt; Bool</code></pre>
</div>
</div>
</li>
<li>
<p><code>(4 ^ 4) ^ 2 = 65536</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">fTwo :: Bool -&gt; Quad -&gt; Quad</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_15_binary_tree">11.15 Binary Tree</h3>
<div class="sect3">
<h4 id="_write_map_for_binarytree">Write map for BinaryTree</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data BinaryTree a =
    Leaf
    | Node (BinaryTree a) a (BinaryTree a)
    deriving (Eq, Ord, Show)

-- Retain the original structure of the tree.

mapTree :: (a -&gt; b) -&gt; BinaryTree a -&gt; BinaryTree b
mapTree _ Leaf = Leaf
mapTree f (Node left a right) =
  Node (mapTree f left) (f a) (mapTree f right)

testTree' :: BinaryTree Integer
testTree' =
  Node (Node Leaf 3 Leaf) 1 (Node Leaf 4 Leaf)

mapExpected =
  Node (Node Leaf 4 Leaf) 2 (Node Leaf 5 Leaf)

-- acceptance test for mapTree
mapOkay =
  if mapTree (+1) testTree' == mapExpected
  then print "yup okay!"
  else error "test failed!"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_convert_binary_trees_to_lists">Convert binary trees to lists</h4>
<div class="paragraph">
<p>Simple solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data BinaryTree a =
    Leaf
    | Node (BinaryTree a) a (BinaryTree a)
    deriving (Eq, Ord, Show)

preorder :: BinaryTree a -&gt; [a]
preorder Leaf = []
preorder (Node left a right) =  a : (preorder left ++ preorder right)

inorder :: BinaryTree a -&gt; [a]
inorder Leaf = []
inorder (Node left a right) =  inorder left ++ [a] ++ inorder right

postorder :: Ord a =&gt; BinaryTree a -&gt; [a]
postorder Leaf = []
postorder (Node left a right) =  postorder left ++ postorder right ++ [a]

testTree :: BinaryTree Integer
testTree = Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf)

testPreorder :: IO ()
testPreorder =
  if preorder testTree == [2, 1, 3]
  then putStrLn "Preorder fine!"
  else putStrLn "Bad news bears."

testInorder :: IO ()
testInorder =
  if inorder testTree == [1, 2, 3]
  then putStrLn "Inorder fine!"
  else putStrLn "Bad news bears."

testPostorder :: IO ()
testPostorder =
  if postorder testTree == [1, 3, 2]
  then putStrLn "Postorder fine!"
  else putStrLn "postorder failed check"

main :: IO ()
main = do
  testPreorder
  testInorder
  testPostorder</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eventually cooler and better solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data BinaryTree a =
    Leaf
    | Node (BinaryTree a) a (BinaryTree a)
    deriving (Eq, Ord, Show)


preorder :: BinaryTree a -&gt; [a]
preorder bt = flattenPre bt []

flattenPre :: BinaryTree a -&gt; [a] -&gt; [a]
flattenPre Leaf l = l
flattenPre (Node left a right) l = a : flattenPre left (flattenPre right l)


inorder :: BinaryTree a -&gt; [a]
inorder bt = flattenIn bt []

flattenIn :: BinaryTree a -&gt; [a] -&gt; [a]
flattenIn Leaf l = l
flattenIn (Node left a right) l = flattenIn left (a : (flattenIn right l))

postorder :: Ord a =&gt; BinaryTree a -&gt; [a]
postorder bt =  flattenPost bt []

flattenPost :: BinaryTree a -&gt; [a] -&gt; [a]
flattenPost Leaf l = l
flattenPost (Node left a right) l = flattenPost left (flattenPost right (a:l))

testTree :: BinaryTree Integer
testTree = Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf)

testPreorder :: IO ()
testPreorder =
  if preorder testTree == [2, 1, 3]
  then putStrLn "Preorder fine!"
  else putStrLn "Bad news bears."

testInorder :: IO ()
testInorder =
  if inorder testTree == [1, 2, 3]
  then putStrLn "Inorder fine!"
  else putStrLn "Bad news bears."

testPostorder :: IO ()
testPostorder =
  if postorder testTree == [1, 3, 2]
  then putStrLn "Postorder fine!"
  else putStrLn "postorder failed check"

main :: IO ()
main = do
  testPreorder
  testInorder
  testPostorder</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_write_foldr_for_binarytree">Write foldr for BinaryTree</h4>
<div class="paragraph">
<p>The big shift was to realize that the folding function needs to take 3 arguments, not the usual 2 as seen in folds so far.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">foldTree :: (a -&gt; b -&gt; b -&gt; b) -&gt; b -&gt; BinaryTree a -&gt; b
foldTree _ acc Leaf = acc
foldTree f acc (Node left a right) = f a (foldTree f acc left) (foldTree f acc right)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The book gives this signature <code>foldTree :: (a &#8594; b &#8594; b) &#8594; b &#8594; BinaryTree a &#8594; b</code> though :/, let&#8217;s do as the book says.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">foldTree :: (a -&gt; b -&gt; b) -&gt; b -&gt; BinaryTree a -&gt; b
foldTree _ acc Leaf = acc
foldTree f acc bt = foldr f acc (flattenIn bt [])


flattenIn :: BinaryTree a -&gt; [a] -&gt; [a]
flattenIn Leaf l = l
flattenIn (Node left a right) l = flattenIn left (a : (flattenIn right l))</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
But this way you cannot recreate the original tree!!!
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_rewrite_map_for_binarytree">Rewrite map for BinaryTree</h4>
<div class="paragraph">
<p>3 parameter fold first</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data BinaryTree a =
    Leaf
    | Node (BinaryTree a) a (BinaryTree a)
    deriving (Eq, Ord, Show)

foldTree :: (a -&gt; b -&gt; b -&gt; b) -&gt; b -&gt; BinaryTree a -&gt; b
foldTree _ acc Leaf = acc
foldTree f acc (Node left a right) = f a (foldTree f acc left) (foldTree f acc right)


mapTree' :: (a -&gt; b) -&gt; BinaryTree a -&gt; BinaryTree b
mapTree' f bt = foldTree mk Leaf bt
  where mk a l r = Node l (f a) r

-- do test also
testTree :: BinaryTree Integer
testTree =
  Node (Node Leaf 3 Leaf) 1 (Node Leaf 4 Leaf)

mapExpected =
  Node (Node Leaf 4 Leaf) 2 (Node Leaf 5 Leaf)

mapOkay =
  if mapTree (+1) testTree == mapExpected
  then print "yup okay!"
  else error "test failed!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>2 parameter fold - BROKEN</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
as mentioned above, this fold ruines the structure
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data BinaryTree a =
    Leaf
    | Node (BinaryTree a) a (BinaryTree a)
    deriving (Eq, Ord, Show)

foldTree :: (a -&gt; b -&gt; b) -&gt; b -&gt; BinaryTree a -&gt; b
foldTree _ acc Leaf = acc
foldTree f acc bt = foldr f acc (inorder bt)

inorder :: BinaryTree a -&gt; [a]
inorder bt = flattenIn bt []

flattenIn :: BinaryTree a -&gt; [a] -&gt; [a]
flattenIn Leaf l = l
flattenIn (Node left a right) l = flattenIn left (a : (flattenIn right l))

mapTree' :: (a -&gt; b) -&gt; BinaryTree a -&gt; BinaryTree b
mapTree' f bt = foldTree mk Leaf bt
  where mk a t = Node l (f a) r

-- do test also
testTree :: BinaryTree Integer
testTree =
  Node (Node Leaf 3 Leaf) 1 (Node Leaf 4 Leaf)

mapExpected =
  Node (Node Leaf 4 Leaf) 2 (Node Leaf 5 Leaf)

mapOkay =
  if mapTree (+1) testTree == mapExpected
  then print "yup okay!"
  else error "test failed!"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_16_chapter_exercises">11.16 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_multiple_choice_4">Multiple choice</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>a) <code><strong>Weekday</strong></code> is a type with five data constructors</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Weekday =
      Monday
    | Tuesday
    | Wednesday
    | Thursday
    | Friday</code></pre>
</div>
</div>
</li>
<li>
<p>c) type of <code><strong>f Friday = "Miller Time"</strong></code> is <code><strong>f :: Weekday &#8594; String</strong></code></p>
</li>
<li>
<p>b) Types defined with the <code><strong>data</strong></code> keyword must begin with a capital letter</p>
</li>
<li>
<p>c) The function <code><strong>g xs = xs !! (length xs - 1)</strong></code> delivers the final element of <code><strong>xs</strong></code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ciphers_2">Ciphers</h4>
<div class="paragraph">
<p>Vigenère cipher</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char

vigenere :: String -&gt; String -&gt; String
vigenere xs ys = vigenere' xs (cycle ys)

vigenere' [] _ = ""
vigenere' (' ':xs) cyp        = ' ' : vigenere' xs cyp
vigenere' (x:xs)   cyp@(y:ys) = docyp x y : vigenere' xs ys
  where base      = ord 'A'
        r         = 26
        dist c    = ord c - base
        docyp x y = chr $ (dist x + dist y) `mod` r + base

main = print $ vigenere "MEET AT DAWN" "ALLY" == "MPPR AE OYWY"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_as_patterns">As-patterns</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><strong>isSubsequenceOf</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">isSubsequenceOf :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Bool
isSubsequenceOf [] [] = True
isSubsequenceOf [] ys = True
isSubsequenceOf _ []  = False
isSubsequenceOf ax@(x:xs) (y:ys)
  | x == y = isSubsequenceOf xs ys
  | otherwise = isSubsequenceOf ax ys</code></pre>
</div>
</div>
</li>
<li>
<p><code><strong>capitalizeWords</strong></code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (toUpper)

capitalizeWords :: String -&gt; [(String, String)]
capitalizeWords xs = map f $ words xs
  where f as@(s:st) = (as, toUpper s : st)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_language_exercises">Language exercises</h4>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
This one was more tricky - review?
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (toUpper, isAlpha)
import Data.List (groupBy)
import Data.Function (on)

capitalizeWord :: String -&gt; String
capitalizeWord [] = []
capitalizeWord (x:xs)
    | isAlpha x = toUpper x : xs
    | otherwise = x : capitalizeWord xs

capitalizeParagraph :: String -&gt; String
capitalizeParagraph xs = concatMap capitalizeWord $ groupBy ((==) `on` (=='.')) xs</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_phone_exercise">Phone exercise</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
don&#8217;t know!
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">{-|
 ---------------------------
 | 1      | 2 ABC | 3 DEF  |
 ___________________________
 | 4 GHI  | 5 JKL | 6 MNO  |
 ---------------------------
 | 7 PQRS | 8 TUV | 9 WXYZ |
 ---------------------------
 | * ^    | 0 + _ | # .,   |
 ---------------------------
-}

import Data.List (maximumBy)

data DaPhone = Sommat

convo :: [String]
convo = ["Wanna play 20 questions",
  "Ya",
  "U 1st haha",
  "Lol ok. Have u ever tasted alcohol lol",
  "Lol ya",
  "Wow ur cool haha. Ur turn",
  "Ok. Do u think I am pretty Lol",
  "Lol ya",
  "Haha thanks just making sure rofl ur turn"]

-- validButtons = "1234567890*#"
type Digit = Char

-- valid presses = [1..4]
type Presses = Int


cellPhonesDead :: DaPhone -&gt; String -&gt; [(Digit, Presses)]
cellPhonesDead = undefined

fingerTaps :: [(Digit, Presses)] -&gt; Presses
fingerTaps = sum . map snd

popularest :: String -&gt; Char
popularest = snd maximumBy fst . frequency

-- from SO
frequency :: Ord a =&gt; [a] -&gt; [(Int,a)]
frequency list = map (\l -&gt; (length l, head l)) (group (sort list))

reverseTaps :: Char -&gt; (Digit, Presses)
reverseTaps = undefined
-- reverseTaps 'a' == [('2', 1)]
-- reverseTaps 'A' == [('*', 1), ('2', 1)]

coolestLtr :: [String] -&gt; Char
coolestLtr = snd . maximumBy fst . maximumBy fst . map frequency

coolestWord :: [String] -&gt; String
coolestWord = snd . maximumBy fst . map frequency . map words</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hutton_s_razor">Hutton’s Razor</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Expr
  = Lit Integer
  | Add Expr Expr

eval :: Expr -&gt; Integer
eval (Lit i) = i
eval (Add exp1 exp2) = eval exp1 + eval exp2


printExpr :: Expr -&gt; String
printExpr (Lit i) = show i
printExpr (Add exp1 exp2) = printExpr exp1 ++ " + " ++ printExpr exp2</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_12_signaling_adversity">12 Signaling adversity</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_12_5_chapter_exercises">12.5 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_determine_the_kinds">Determine the kinds</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><strong>id :: a &#8594; a</strong></code> kind of <code><strong>a</strong></code> is <code><strong>*</strong></code></p>
</li>
<li>
<p><code><strong>r :: a &#8594; f a</strong></code> kind of <code><strong>a</strong></code> is <code><strong>*</strong></code>, kind of <code><strong>f a</strong></code> is <code><strong>* -> *</strong></code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_string_processing">String processing</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Replace "the" with "a".</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.List (intercalate)

notThe :: String -&gt; Maybe String
notThe s
  | s == "the" = Nothing
  | otherwise = Just s

replaceThe :: String -&gt; String
replaceThe str = intercalate " " $ map athe $ fmap notThe $ words str
  where athe Nothing = "a"
        athe (Just x) = x</code></pre>
</div>
</div>
</li>
<li>
<p>recursive count</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">countTheBeforeVowel :: String -&gt; Integer
countTheBeforeVowel s = f 0 $ words s

isVowel :: Char -&gt; Bool
isVowel x = x `elem` "aeiou"

f :: Integer -&gt; [String] -&gt; Integer
f n (x:y:ys)
  | x == "the" &amp;&amp; isVowel (head y) = f (n + 1) (y:ys)
  | otherwise = f n ys
f n _ = n</code></pre>
</div>
</div>
</li>
<li>
<p>number of vowels in a word - changed the siganture to <code>Int</code> instead of <code>Integer</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">countVowels :: String -&gt; Int
countVowels = length . wordVowels

isVowel :: Char -&gt; Bool
isVowel x = x `elem` "aeiou"

wordVowels :: String -&gt; String
wordVowels = filter isVowel</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_validate_the_word">Validate the word</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">newtype Word' =
  Word' String
  deriving (Eq, Show)

vowels = "aeiou"

mkWord :: String -&gt; Maybe Word'
mkWord w = if lv &lt; lc then Just (Word' w) else Nothing
  where lv = length $ filter ((flip elem) vowels) w
        lc = length w - lv</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_it_s_only_natural">It’s only Natural</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Nat =
  Zero
  | Succ Nat
  deriving (Eq, Show)

natToInteger :: Nat -&gt; Integer
natToInteger Zero = 0
natToInteger (Succ n) = 1 + natToInteger n

integerToNat :: Integer -&gt; Maybe Nat
integerToNat i
  | i &lt; 0 = Nothing
  | otherwise = Just (tn i)
  where tn i
          | i == 0 = Zero
          | otherwise = Succ (tn (i - 1))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_small_library_for_maybe">Small library for Maybe</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>boolean check</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">isJust :: Maybe a -&gt; Bool
isJust Nothing = False
isJust _ = True

isNothing :: Maybe a -&gt; Bool
isNothing = not . isJust</code></pre>
</div>
</div>
</li>
<li>
<p>Maybe catamorphism</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">mayybee :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
mayybee b _ Nothing = b
mayybee _ f (Just a) = f a</code></pre>
</div>
</div>
</li>
<li>
<p>fallback</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">mayybee :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
mayybee b _ Nothing = b
mayybee _ f (Just a) = f a

fromMaybe :: a -&gt; Maybe a -&gt; a
fromMaybe a m = mayybee a id m</code></pre>
</div>
</div>
</li>
<li>
<p>Converting between List and Maybe</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">listToMaybe :: [a] -&gt; Maybe a
listToMaybe [] = Nothing
listToMaybe (x:_) = Just x

maybeToList :: Maybe a -&gt; [a]
maybeToList Nothing = []
maybeToList (Just a) = [a]</code></pre>
</div>
</div>
</li>
<li>
<p>drop the Nothing values from our list</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">catMaybes :: [Maybe a] -&gt; [a]
catMaybes [] = []
catMaybes (Nothing:xs) = catMaybes xs
catMaybes (Just a:xs) = a : catMaybes xs

-- using fold
catMaybes' :: [Maybe a] -&gt; [a]
catMaybes' [] = []
catMaybes' xs = foldr f [] xs
  where f Nothing xs'  = xs'
        f (Just a) xs' = a : xs'</code></pre>
</div>
</div>
</li>
<li>
<p>flipMaybe</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">flipMaybe :: [Maybe a] -&gt; Maybe [a]
flipMaybe [] = Just []
flipMaybe xs = foldr f (Just []) xs
  where f _ Nothing = Nothing
        f Nothing _ = Nothing
        f (Just a) (Just b) = Just (a:b)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_small_library_for_either">Small library for Either</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>use foldr</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">lefts' :: [Either a b] -&gt; [a]
lefts' = foldr f []
  where f (Left a) xs = a : xs
        f (Right b) xs = xs

-- lefts' [Left 1, Left 2]
-- [1, 2]
-- lefts' [Right 0, Left 5, Right 4]
-- [5]</code></pre>
</div>
</div>
</li>
<li>
<p>use foldr well, same as last one (don&#8217;t see the point much, just use a instead of b)</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">rights' :: [Either a b] -&gt; [b]
rights' = foldr f []
  where f (Left a) xs = xs
        f (Right b) xs = b : xs

-- rights' [Left 1, Left 2]
-- []
-- rights' [Right 0, Left 5, Right 4]
-- [0, 4]</code></pre>
</div>
</div>
</li>
<li>
<p>partitionEithers</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">partitionEithers' :: [Either a b] -&gt; ([a], [b])
partitionEithers' = foldr f ([], [])
  where f (Left a) (xs, ys) = (a:xs, ys)
        f (Right b) (xs, ys) = (xs, b:ys)</code></pre>
</div>
</div>
</li>
<li>
<p>eitherMaybe</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">eitherMaybe' :: (b -&gt; c) -&gt; Either a b -&gt; Maybe c
eitherMaybe' _ (Left _) = Nothing
eitherMaybe' f (Right b) = Just (f b)

-- eitherMaybe' even (Right 2)
-- eitherMaybe' even (Left 2)</code></pre>
</div>
</div>
</li>
<li>
<p>either'</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">either' :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
either' fl _ (Left a) = fl a
either' _ fr (Right b) = fr b

-- either' even odd (Left 2)
-- either' even odd (Right 2)</code></pre>
</div>
</div>
</li>
<li>
<p>use either'</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
I don&#8217;t see the point :(
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">either' :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
either' fl _ (Left a) = fl a
either' _ fr (Right b) = fr b

eitherMaybe'' :: (b -&gt; c) -&gt; Either a b -&gt; Maybe c
eitherMaybe'' _ (Left _) = Nothing
eitherMaybe'' f eb = Just (either' undefined f eb)

-- eitherMaybe'' even (Right 2)
-- eitherMaybe'' even (Left 2)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_write_your_own_iterate_and_unfoldr">Write your own iterate and unfoldr</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>myIterate using recursion</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myIterate :: (a -&gt; a) -&gt; a -&gt; [a]
myIterate f a = a : myIterate f (f a)</code></pre>
</div>
</div>
</li>
<li>
<p>myUnfoldr</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myUnfoldr :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a]
myUnfoldr f b = case f b of
                Nothing -&gt; []
                Just (x, y) -&gt; x : myUnfoldr f y</code></pre>
</div>
</div>
</li>
<li>
<p>myIterate into betterIterate using myUnfoldr</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">myUnfoldr :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a]
myUnfoldr f b = case f b of
                Nothing -&gt; []
                Just (x, y) -&gt; x : myUnfoldr f y

betterIterate :: (a -&gt; a) -&gt; a -&gt; [a]
betterIterate f x = myUnfoldr (\x -&gt; Just (x, f x)) x</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_finally_something_other_than_a_list">Finally something other than a list!</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data BinaryTree a =
    Leaf
  | Node (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Ord, Show)


unfold :: (a -&gt; Maybe (a,b,a)) -&gt; a -&gt; BinaryTree b
unfold f b = case f b of
                Nothing -&gt; Leaf
                Just (x, y, z) -&gt; Node (unfold f x) y (unfold f z)

treeBuild :: Integer -&gt; BinaryTree Integer
treeBuild n = unfold f 0
  where f m
          | m == n = Nothing
          | otherwise = Just (m + 1, m, m + 1)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_13_building_projects_in_haskell">13 Building projects in Haskell</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Used <code>stack</code> instead of <code>cabal</code></p>
</div>
<div class="paragraph">
<p>Files at <a href="https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch13" class="bare">https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch13</a></p>
</div>
<div class="paragraph">
<p><a href="https://github.com/commercialhaskell/stack/blob/master/doc/faq.md" class="bare">https://github.com/commercialhaskell/stack/blob/master/doc/faq.md</a></p>
</div>
<div class="paragraph">
<p><a href="https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md" class="bare">https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md</a></p>
</div>
<div class="paragraph">
<p><a href="http://docs.haskellstack.org/en/stable/README.html" class="bare">http://docs.haskellstack.org/en/stable/README.html</a></p>
</div>
<div class="sect3">
<h4 id="_differences_between_cabal_and_stack">Differences between cabal and stack</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>stack new proj</code> instead of <code>mkdir proj; cd proj; cabal init</code></p>
</li>
<li>
<p><code>stack</code> creates <code>Lib</code> automatically</p>
</li>
<li>
<p><code>cabal sandbox init</code> no need</p>
</li>
<li>
<p><code>stack build</code></p>
</li>
<li>
<p><code>stack exec proj-exe</code></p>
</li>
<li>
<p><code>stack ghci</code> or <code>stack repl</code> - they appear to be identical</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_13_2_managing_projects_with_cabal">13.2 Managing projects with Cabal</h3>
<div class="sect3">
<h4 id="_hello_haskell">hello-haskell</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>stack new hello-haskell</code></p>
</li>
<li>
<p><code>cd hello-haskell</code></p>
</li>
<li>
<p>make changes needed</p>
</li>
<li>
<p><code>stack build</code></p>
</li>
<li>
<p><code>stack exec hello-haskell-exe</code></p>
</li>
<li>
<p>if you need REPL with project loaded <code>stack repl</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sources at <a href="https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch13/hello-haskell" class="bare">https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch13/hello-haskell</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_13_4_importing_modules">13.4 Importing modules</h3>
<div class="sect3">
<h4 id="_intermission_check_your_understanding">Intermission: Check your understanding</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>forever</code> and <code>when</code></p>
</li>
<li>
<p>all the import without <code>qualified</code> keyword</p>
</li>
<li>
<p>everything exported in <code>Database.Blacktip.Types</code></p>
</li>
<li>
<p>details</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>just look for what is after the <code>as</code> keyword in the imports</p>
</li>
<li>
<p><code>Filesystem</code></p>
</li>
<li>
<p><code>Control.Monad</code></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_13_8_loading_code_from_another_project">13.8 Loading code from another project</h3>
<div class="sect3">
<h4 id="_call_em_up">call-em-up</h4>
<div class="paragraph">
<p>Sources at <a href="https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch13/call-em-up" class="bare">https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch13/call-em-up</a></p>
</div>
<div class="paragraph">
<p>call-em-up sees hello-haskell by including <code>- ../hello-haskell</code> in <code>packages</code> section in <code>stack.yaml</code>. Not sure if this is the right way.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_13_9_do_syntax_and_io">13.9 do syntax and IO</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>error as expected</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">main :: IO Bool
main = do c &lt;- getChar
          c' &lt;- getChar
          c == c'</code></pre>
</div>
</div>
</li>
<li>
<p>consumes two characters and prints <code>True</code> or <code>False</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">main :: IO Bool
main = do c &lt;- getChar
          c' &lt;- getChar
          return (c == c')</code></pre>
</div>
</div>
</li>
<li>
<p>consumes two characters and prints <code>True</code> if true, or nothing.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">main :: IO ()
main = do c &lt;- getChar
          c' &lt;- getChar
          if c == c'
          then putStrLn "True"
          else return ()</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_13_15_chapter_exercises">13.15 Chapter exercises</h3>
<div class="sect3">
<h4 id="_hangman_game_logic">Hangman game logic</h4>
<div class="paragraph">
<p>Sources at <a href="https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch13/hangman" class="bare">https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch13/hangman</a></p>
</div>
<div class="paragraph">
<p>To count only incorrect guesses, I have modified <code>gameOver</code> condition to <code>if (length guessed - length (filter isJust discovered)) &gt; 7 then</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_modifying_code">Modifying code</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Caesar and Vigenere cyphers taking input from user</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (ord, chr, isAlpha)

caesar :: String -&gt; Int -&gt; String
caesar [] _ = []
caesar (x:xs) n
  | isAlpha x = docyp x n (+) : caesar xs n
  | otherwise = x : caesar xs n


unCaesar :: String -&gt; Int -&gt; String
unCaesar [] _ = []
unCaesar (x:xs) n
  | isAlpha x = docyp x n (-) : unCaesar xs n
  | otherwise = x: unCaesar xs n

docyp :: Char -&gt; Int -&gt; (Int -&gt; Int -&gt; Int) -&gt; Char
docyp x n f = chr $ f (ord x - base) n `mod` r + base
  where base = ord 'a'
        r = 26

t = "abc xyz"
shift = 5

cipherOk = unCaesar (caesar t shift) shift == t

main :: IO ()
main = do
  putStr "input caesar shift: "
  cyp &lt;- getLine
  putStr "input text: "
  str &lt;- getLine
  putStrLn $ "encrypted text: " ++ caesar str (read cyp :: Int)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char

vigenere :: String -&gt; String -&gt; String
vigenere xs ys = vigenere' xs (cycle ys)

vigenere' :: String -&gt; String -&gt; String
vigenere' [] _ = ""
vigenere' xs [] = xs
vigenere' (x:xs) cyp@(y:ys)
  | x == ' ' = x : vigenere' xs cyp
  | otherwise = docyp x y : vigenere' xs ys
  where base = ord 'A'
        r = 26
        dist c = ord c - base
        docyp a b = chr $ (dist a + dist b) `mod` r + base

main :: IO ()
main = do
  putStr "input vigenere cypher: "
  cyp &lt;- getLine
  putStr "input text: "
  str &lt;- getLine
  putStrLn $ "encrypted text: " ++ vigenere str cyp</code></pre>
</div>
</div>
</li>
<li>
<p>using <code>exitSuccess</code> in palindrome</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Control.Monad
import System.Exit (exitSuccess)

palindrome :: IO ()
palindrome = forever $ do
  putStr "type text to check for palindrome: "
  line1 &lt;- getLine
  case line1 == reverse line1 of
    True -&gt; do
              putStrLn "It's a palindrome!"
              exitSuccess
    False -&gt; putStrLn "Nope!"

main :: IO ()
main = palindrome</code></pre>
</div>
</div>
</li>
<li>
<p>palindrome on sentences</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
not sure I get the assignment other than using <code>toLower</code>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Control.Monad
import System.Exit (exitSuccess)
import Data.Char (toLower)

norm :: String -&gt; String
norm = map toLower

palindrome :: IO ()
palindrome = forever $ do
  putStr "type text to check for palindrome: "
  line1 &lt;- getLine
  case norm line1 == reverse (norm line1) of
    True -&gt; do
              putStrLn "It's a palindrome!"
              exitSuccess
    False -&gt; putStrLn "Nope!"

main :: IO ()
main = palindrome</code></pre>
</div>
</div>
</li>
<li>
<p><code>gimmePerson</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">type Name = String
type Age = Integer

data Person = Person Name Age deriving Show

data PersonInvalid = NameEmpty
  | AgeTooLow
  | PersonInvalidUnknown String
  deriving (Eq, Show)

mkPerson :: Name
          -&gt; Age
          -&gt; Either PersonInvalid Person
mkPerson name age
  | name /= "" &amp;&amp; age &gt; 0 = Right $ Person name age
  | name == "" = Left NameEmpty
  | age &lt;= 0 = Left AgeTooLow
  | otherwise = Left $ PersonInvalidUnknown $
                      "Name was: " ++ show name ++
                      " Age was: " ++ show age

gimmePerson :: IO ()
gimmePerson = do
  putStr "age: "
  age &lt;- getLine
  putStr "name: "
  name &lt;- getLine
  case mkPerson name (read age :: Integer) of
    Right p -&gt; putStrLn $ "Yay! Successfully got a person:" ++ show p
    Left NameEmpty -&gt; putStrLn "Empty name"
    Left AgeTooLow -&gt; putStrLn "Age must be bigger than 0"
    Left (PersonInvalidUnknown err) -&gt; putStrLn $ "Unknown invalid: " ++ err</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_14_testing">14 Testing</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_14_3_conventional_testing">14.3 Conventional testing</h3>
<div class="paragraph">
<p><a href="https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch14/addition" class="bare">https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch14/addition</a></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>stack build</code></p>
</li>
<li>
<p><code>stack test</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Main where

import Test.Hspec
import Test.QuickCheck
import Addition

main :: IO ()
main = hspec $ do
  describe "Addition" $ do
    it "1 + 1 is greater than 1" $ do
      (1 + 1) &gt; (1 :: Integer) `shouldBe` True
    it "2 + 2 is equal to 4" $ do
      2 + 2 `shouldBe` 4
    it "15 divided by 3 is 5" $ do
      dividedBy 15 3 `shouldBe` (5, 0)
    it "22 divided by 5 is 4 remainder 2" $ do
      dividedBy 22 5 `shouldBe` (4, 2)
    it "5 multiplied by 3 is 15" $ do
      recMul 5 3 `shouldBe` 15
    it "10 multiplied by 0 is 0" $ do
      recMul 10 0 `shouldBe` 0
    it "x + 1 is always greater than x" $ do
      property $ \x -&gt; x + 1 &gt; (x :: Int)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_14_5_morse_code">14.5 Morse code</h3>
<div class="paragraph">
<p><a href="https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch14/morsecode" class="bare">https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch14/morsecode</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Main where

import qualified Data.Map as M
import Morse
import Test.QuickCheck

allowedChars :: [Char]
allowedChars = M.keys letterToMorse

allowedMorse :: [String]
allowedMorse = M.elems letterToMorse

charGen :: Gen Char
charGen = elements allowedChars

morseGen :: Gen Morse
morseGen = elements allowedMorse

prop_thereAndBackAgain :: Property
prop_thereAndBackAgain =
  forAll charGen
  (\c -&gt; ((charToMorse c) &gt;&gt;= morseToChar) == Just c)

main :: IO ()
main = quickCheck prop_thereAndBackAgain</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_14_6_chapter_exercises">14.6 Chapter Exercises</h3>
<div class="sect3">
<h4 id="_validating_numbers_into_words">Validating numbers into words</h4>
<div class="paragraph">
<p><a href="https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch14/wordnumber" class="bare">https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch14/wordnumber</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">module Main where

import Test.Hspec
import WordNumber (digitToWord, digits, wordNumber)

main :: IO ()
main = hspec $ do
  describe "digitToWord does what we want" $ do
    it "returns zero for 0" $ do
      digitToWord 0 `shouldBe` "zero"
    it "returns one for 1" $ do
      digitToWord 1 `shouldBe` "one"
  describe "digits does what we want" $ do
    it "returns [1] for 1" $ do
      digits 1 `shouldBe` [1]
    it "returns [1, 0, 0] for 100" $ do
      digits 100 `shouldBe` [1, 0, 0]
  describe "wordNumber does what we want" $ do
    it "returns one-zero-zero for 100" $ do
      wordNumber 100 `shouldBe` "one-zero-zero"
    it "returns nine-zero-zero-one for 9001" $ do
      wordNumber 9001 `shouldBe` "nine-zero-zero-one"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_quickcheck">Using QuickCheck</h4>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
excercises 8 I have no idea
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>propHalf <code>+++ OK, passed 100 tests.</code></p>
</li>
<li>
<p>propSort <code>+++ OK, passed 100 tests.</code></p>
</li>
<li>
<p>plusAssociative <code>+++ OK, passed 100 tests.</code></p>
<div class="paragraph">
<p>plusCommutative <code>+++ OK, passed 100 tests.</code></p>
</div>
</li>
<li>
<p>multiAssociative <code>+++ OK, passed 100 tests.</code></p>
<div class="paragraph">
<p>multiCommutative <code>+++ OK, passed 100 tests.</code></p>
</div>
</li>
<li>
<p>propQuotRem <code>+++ OK, passed 100 tests.</code></p>
<div class="paragraph">
<p>propDivMod <code>+++ OK, passed 100 tests.</code></p>
</div>
</li>
<li>
<p>powerAssociative</p>
<div class="literalblock">
<div class="content">
<pre>*** Failed! Falsifiable (after 1 test):
0
0
0</pre>
</div>
</div>
<div class="paragraph">
<p>powerCommutative</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*** Failed! Falsifiable (after 2 tests):
1
0</pre>
</div>
</div>
</li>
<li>
<p>propReverse <code>+++ OK, passed 100 tests.</code></p>
</li>
<li>
<p>NOT DONE</p>
</li>
<li>
<p>inConcatProp</p>
<div class="literalblock">
<div class="content">
<pre>*** Failed! Falsifiable (after 2 tests and 2 shrinks):
"a"
"b"</pre>
</div>
</div>
<div class="paragraph">
<p>concatProp <code>+++ OK, passed 100 tests.</code></p>
</div>
</li>
<li>
<p>lenTakeProb</p>
<div class="literalblock">
<div class="content">
<pre>*** Failed! Falsifiable (after 3 tests and 1 shrink):
2
""</pre>
</div>
</div>
</li>
<li>
<p>idProp <code>+++ OK, passed 100 tests.</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch14/usingquickcheck" class="bare">https://github.com/lukleh/haskell-book-excercises/tree/gh-pages/ch14/usingquickcheck</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck
-- import Test.QuickCheck.Instances.List (anyList)
import Test.QuickCheck.Modifiers (NonZero)

import Data.List (sort)

-- 1.
half :: Fractional a =&gt; a -&gt; a
half x = x / 2

halfIdentity :: Fractional a =&gt; a -&gt; a
halfIdentity = (*2) . half

propHalf :: Float -&gt; Bool
propHalf x = halfIdentity x == x

-- 2.
listOrdered :: (Ord a) =&gt; [a] -&gt; Bool
listOrdered xs = snd $ foldr go (Nothing, True) xs
  where go _ status@(_, False) = status
        go y (Nothing, t) = (Just y, t)
        go y (Just x, t) = (Just y, x &gt;= y)

propSort :: [Int] -&gt; Bool
propSort = listOrdered . sort

-- 3.
plusAssociative :: Int -&gt; Int -&gt; Int -&gt; Bool
plusAssociative x y z =
  x + (y + z) == (x + y) + z

plusCommutative :: Int -&gt; Int -&gt; Bool
plusCommutative x y =
  x + y == y + x

-- 4.
multiAssociative :: Int -&gt; Int -&gt; Int -&gt; Bool
multiAssociative x y z =
  x * (y * z) == (x * y) * z

multiCommutative :: Int -&gt; Int -&gt; Bool
multiCommutative x y =
  x * y == y * x

-- 5.
propQuotRem :: NonZero Int -&gt; NonZero Int -&gt; Bool
propQuotRem (NonZero x) (NonZero y) =
  (quot x y)*y + (rem x y) == x

propDivMod :: NonZero Int -&gt; NonZero Int -&gt; Bool
propDivMod (NonZero x) (NonZero y) =
  (div x y)*y + (mod x y) == x

-- 6.
powerAssociative :: Int -&gt; Int -&gt; Int -&gt; Bool
powerAssociative x y z = x ^ (y ^ z) == (x ^ y) ^ z

powerCommutative :: Int -&gt; Int -&gt; Bool
powerCommutative x y = x ^ y == y ^ x

-- 7.
propReverse :: [Int] -&gt; Bool
propReverse xs = (reverse . reverse) xs == xs

-- 8.
-- applyProp = (f $ a) == (f a)

-- composeProp = f . g == \x -&gt; f (g x)

-- 9.
inConcatProp :: String -&gt; String -&gt; Bool
inConcatProp xs ys = foldr (:) xs ys == (++) xs ys

concatProp :: [String] -&gt; Bool
concatProp xs = foldr (++) [] xs == concat xs

-- 10.
lenTakeProb :: Int -&gt; String -&gt; Bool
lenTakeProb n xs = length (take n xs) == n

-- 11.
idProp :: Int -&gt; Bool
idProp x = (read (show x)) == x


main :: IO ()
main = do
  quickCheck propHalf
  quickCheck propSort
  quickCheck plusAssociative
  quickCheck plusCommutative
  quickCheck multiAssociative
  quickCheck multiCommutative
  quickCheck propQuotRem
  quickCheck propDivMod
  quickCheck powerAssociative
  quickCheck powerCommutative
  quickCheck propReverse
  quickCheck inConcatProp
  quickCheck concatProp
  quickCheck lenTakeProb
  quickCheck idProp</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_failure">Failure</h4>
<div class="paragraph">
<p>Floating point precission cannot guarantee equality</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (quickCheck, verboseCheck)

square x = x * x

squareIdentity :: Double -&gt; Double
squareIdentity = square . sqrt

squareProp x = squareIdentity x == x

main = do
  quickCheck squareProp</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*Main&gt; main
*** Failed! Falsifiable (after 2 tests and 1037 shrinks):
2.225078033262077e-308</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_idempotence">Idempotence</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (quickCheck, verboseCheck)
import Data.Char (toUpper, toLower)
import Data.List (sort)


twice f = f . f
fourTimes = twice . twice

capitalizeWord :: String -&gt; String
capitalizeWord w
  | null w = w
  | otherwise = [toUpper firstLetter] ++ map toLower others
  where ([firstLetter], others) = splitAt 1 w

propCapitalize :: String -&gt; Bool
propCapitalize x =
  (capitalizeWord x == twice capitalizeWord x) &amp;&amp; (capitalizeWord x == fourTimes capitalizeWord x)

propSort :: [Int] -&gt; Bool
propSort x =
  (sort x == twice sort x) &amp;&amp; (sort x == fourTimes sort x)


main = do
  quickCheck propCapitalize
  quickCheck propSort</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>+++ OK, passed 100 tests.
+++ OK, passed 100 tests.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_make_a_gen_random_generator_for_the_datatype">Make a Gen random generator for the datatype</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (sample, elements, frequency, Gen)

data Fool =
      Fulse
    | Frue
    deriving (Eq, Show)

genFool :: Gen Fool
genFool = elements [Fulse, Frue]

genFoolMoreFulse :: Gen Fool
genFoolMoreFulse = frequency [(2, return Fulse),
                              (1, return Frue)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hangman_testing">Hangman testing</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
not done, will have to come back to this later
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">fillInCharacter :: Puzzle -&gt; Char -&gt; Puzzle
fillInCharacter (Puzzle word filledInSoFar s) c =
  Puzzle word newFilledInSoFar (c : s)
  where zipper guessed wordChar guessChar =
          if wordChar == guessed
          then Just wordChar
          else guessChar
        newFilledInSoFar =
          zipWith (zipper c) word filledInSoFar

handleGuess :: Puzzle -&gt; Char -&gt; IO Puzzle
handleGuess puzzle guess = do
  putStrLn $ "Your guess was: " ++ [guess]
  case (charInWord puzzle guess
      , alreadyGuessed puzzle guess) of
    (_, True) -&gt; do
      putStrLn "You already guessed that\
                \ character, pick something else!"
      return puzzle
    (True, _) -&gt; do
      putStrLn "This character was in the word,\
                \ filling in the word accordingly"
      return (fillInCharacter puzzle guess)
    (False, _) -&gt; do
      putStrLn "This character wasn't in\
                \ the word, try again."
      return (fillInCharacter puzzle guess)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_validating_ciphers">Validating ciphers</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
need to do proper generators
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Char (ord, chr, isAlpha)
import Test.QuickCheck (quickCheck, verboseCheck, Gen)

caesar :: String -&gt; Int -&gt; String
caesar [] _ = []
caesar (x:xs) n
  | isAlpha x = docyp x n (+) : caesar xs n
  | otherwise = x : caesar xs n


unCaesar :: String -&gt; Int -&gt; String
unCaesar [] _ = []
unCaesar (x:xs) n
  | isAlpha x = docyp x n (-) : unCaesar xs n
  | otherwise = x: unCaesar xs n

docyp :: Char -&gt; Int -&gt; (Int -&gt; Int -&gt; Int) -&gt; Char
docyp x n f = chr $ f (ord x - base) n `mod` range + base
  where base = ord 'a'
        range = 26


-- vigenere "MEET AT DAWN" "ALLY" = "ALLY AL LYAL"

vigenere :: String -&gt; String -&gt; String
vigenere [] _ = ""
vigenere xs ys = vigenere' xs (cycle (map ord ys)) where
  vigenere' (x:xs) cyp@(n:ns)
    | isAlpha x = docyp x n (+) : vigenere' xs ns
      | otherwise = x : vigenere' xs cyp

unVigenere :: String -&gt; String -&gt; String
unVigenere [] _ = ""
unVigenere xs ys = unVigenere' xs (cycle (map ord ys)) where
  unVigenere' (x:xs) cyp@(n:ns)
    | isAlpha x = docyp x n (+) : unVigenere' xs ns
      | otherwise = x : unVigenere' xs cyp


-- capitalGen :: Gen Char
-- capitalGen = elements [A..Z]

-- propCaesar :: Property
-- propCaesar =
--   forAll capitalGen
--   (\c -&gt; (unCaesar (caesar text shift) shift) == text)


propCaesar :: String -&gt; Int -&gt; Bool
propCaesar text shift = (unCaesar (caesar text shift) shift) == text

propVigenere :: String -&gt; String -&gt; Bool
propVigenere text code = (unVigenere (vigenere text code) code) == text

main :: IO ()
main = do
  verboseCheck propCaesar
  verboseCheck propVigenere</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_monoid_semigroup">15 Monoid, Semigroup</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_15_10_reusing_algebras_by_asking_for_algebras">15.10 Reusing algebras by asking for algebras</h3>
<div class="sect3">
<h4 id="_exercise_2">Exercise</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">data Optional a =
    Nada
  | Only a
  deriving (Eq, Show)

instance Monoid a =&gt; Monoid (Optional a) where
  mempty                      = Nada
  mappend Nada      (Only a)  = Only a
  mappend Nada      Nada      = Nada
  mappend (Only a)  Nada      = Only a
  mappend (Only a)  (Only b)  = Only (mappend a b)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_15_11_madness">15.11 Madness</h3>
<div class="paragraph">
<p>I guess the <code>madlibbinBetter'</code> is "better", but nothing to blow my mind as of now.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Monoid

type Verb = String
type Adjective = String
type Adverb = String
type Noun = String
type Exclamation = String

madlibbin' :: Exclamation
              -&gt; Adverb
              -&gt; Noun
              -&gt; Adjective
              -&gt; String
madlibbin' e adv noun adj =
    e &lt;&gt; "! he said " &lt;&gt;
    adv &lt;&gt; " as he jumped into his car " &lt;&gt;
    noun &lt;&gt; " and drove off with this " &lt;&gt;
    adj &lt;&gt; " wife."


madlibbinBetter' :: Exclamation
                    -&gt; Adverb
                    -&gt; Noun
                    -&gt; Adjective
                    -&gt; String
madlibbinBetter' e adv noun adj = mconcat [e, "! he said ", adv, " as he jumped into his car ", noun, " and drove off with this ", adj, " wife."]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_15_12_better_living_through_quickcheck">15.12 Better living through QuickCheck</h3>
<div class="sect3">
<h4 id="_intermission_exercise_2">Intermission: Exercise</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Monoid
import Test.QuickCheck

data Optional a =
    Nada
  | Only a
  deriving (Eq, Show)

monoidAssoc :: (Eq m, Monoid m) =&gt; m -&gt; m -&gt; m -&gt; Bool
monoidAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

monoidLeftIdentity :: (Eq m, Monoid m) =&gt; m -&gt; Bool
monoidLeftIdentity a = (mempty &lt;&gt; a) == a

monoidRightIdentity :: (Eq m, Monoid m) =&gt; m -&gt; Bool
monoidRightIdentity a = (a &lt;&gt; mempty) == a

newtype First' a =
  First' { getFirst' :: Optional a }
  deriving (Eq, Show)

instance Arbitrary a =&gt; Arbitrary (First' a) where
  arbitrary = do
    x &lt;- arbitrary
    frequency [ (1, return (First' (Only x)))
              , (1, return (First' Nada))]

instance Monoid (First' a) where
  mempty = First' Nada
  mappend (First' (Only x)) _ = First' (Only x)
  mappend (First' Nada) (First' (Only x)) = First' (Only x)
  mappend _ _ = First' Nada

firstMappend :: First' a -&gt; First' a -&gt; First' a
firstMappend = mappend

type FirstMappend =
     First' String
  -&gt; First' String
  -&gt; First' String
  -&gt; Bool

main :: IO ()
main = do
  quickCheck (monoidAssoc :: FirstMappend)
  quickCheck (monoidLeftIdentity :: First' String -&gt; Bool)
  quickCheck (monoidRightIdentity :: First' String -&gt; Bool)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_15_14_chapter_exercises">15.14 Chapter exercises</h3>
<div class="sect3">
<h4 id="_semigroup_exercises">Semigroup exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>data Trivial = Trivial deriving (Eq, Show)</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck)
import Data.Semigroup (Semigroup, (&lt;&gt;))

data Trivial = Trivial deriving (Eq, Show)

instance Semigroup Trivial where
  _ &lt;&gt; _ = Trivial

instance Arbitrary Trivial where
  arbitrary = return Trivial

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type TrivialAssoc = Trivial -&gt; Trivial -&gt; Trivial -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: TrivialAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype Identity a = Identity a</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck)
import Data.Semigroup (Semigroup, (&lt;&gt;))

newtype Identity a = Identity a deriving (Eq, Show)

instance Semigroup a =&gt; Semigroup (Identity a) where
  (Identity a) &lt;&gt; (Identity b) = Identity (a &lt;&gt; b)

instance Arbitrary a =&gt; Arbitrary (Identity a) where
  arbitrary = do
    a &lt;- arbitrary
    return (Identity a)

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type IdentityAssoc = Identity String -&gt; Identity String -&gt; Identity String -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: IdentityAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>data Two a b = Two a b</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck)
import Data.Semigroup (Semigroup, (&lt;&gt;))

data Two a b = Two a b deriving (Eq, Show)

instance (Semigroup a, Semigroup b) =&gt; Semigroup (Two a b) where
  (Two a b) &lt;&gt; (Two c d) = Two (a &lt;&gt; c) (b &lt;&gt; d)

instance (Arbitrary a, Arbitrary b) =&gt; Arbitrary (Two a b) where
  arbitrary = do
    a &lt;- arbitrary
    b &lt;- arbitrary
    return (Two a b)

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type TwoAssoc = Two String Ordering -&gt; Two String Ordering -&gt; Two String Ordering -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: TwoAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>data Three a b c = Three a b c</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck)
import Data.Semigroup (Semigroup, (&lt;&gt;))

data Three a b c = Three a b c deriving (Eq, Show)

instance (Semigroup a, Semigroup b, Semigroup c) =&gt; Semigroup (Three a b c) where
  (Three a b c) &lt;&gt; (Three a1 b1 c1) = Three (a &lt;&gt; a1) (b &lt;&gt; b1) (c &lt;&gt; c1)

instance (Arbitrary a, Arbitrary b, Arbitrary c) =&gt; Arbitrary (Three a b c) where
  arbitrary = do
    a &lt;- arbitrary
    b &lt;- arbitrary
    c &lt;- arbitrary
    return (Three a b c)

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type ThreeAssoc = Three String Ordering String -&gt; Three String Ordering String -&gt; Three String Ordering String -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: ThreeAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>data Four a b c d = Four a b c d</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck)
import Data.Semigroup (Semigroup, (&lt;&gt;), Sum)

data Four a b c d = Four a b c d deriving (Eq, Show)

instance (Semigroup a, Semigroup b, Semigroup c, Semigroup d) =&gt; Semigroup (Four a b c d) where
  (Four a b c d) &lt;&gt; (Four a1 b1 c1 d1) = Four (a &lt;&gt; a1) (b &lt;&gt; b1) (c &lt;&gt; c1) (d &lt;&gt; d1)

instance (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) =&gt; Arbitrary (Four a b c d) where
  arbitrary = do
    a &lt;- arbitrary
    b &lt;- arbitrary
    c &lt;- arbitrary
    d &lt;- arbitrary
    return (Four a b c d)

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type FourAssoc = Four String Ordering String String -&gt; Four String Ordering String String -&gt; Four String Ordering String String -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: FourAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype BoolConj = BoolConj Bool</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;))

newtype BoolConj = BoolConj Bool deriving (Eq, Show)

instance Semigroup BoolConj where
  (BoolConj a) &lt;&gt; (BoolConj b) = BoolConj (a &amp;&amp; b)

instance Arbitrary BoolConj where
  arbitrary = do
    a &lt;- arbitrary
    elements [(BoolConj a), (BoolConj a)]

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type BoolConjAssoc = BoolConj -&gt; BoolConj -&gt; BoolConj -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: BoolConjAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype BoolDisj = BoolDisj Bool</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;))

newtype BoolDisj = BoolDisj Bool deriving (Eq, Show)

instance Semigroup BoolDisj where
  (BoolDisj a) &lt;&gt; (BoolDisj b) = BoolDisj (a || b)

instance Arbitrary BoolDisj where
  arbitrary = do
    a &lt;- arbitrary
    elements [(BoolDisj a), (BoolDisj a)]

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type BoolDisjAssoc = BoolDisj -&gt; BoolDisj -&gt; BoolDisj -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: BoolDisjAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>data Or a b = Fst a | Snd b</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;))

data Or a b = Fst a | Snd b deriving (Eq, Show)

instance (Semigroup a, Semigroup b) =&gt; Semigroup (Or a b) where
  (Snd a) &lt;&gt; _ = Snd a
  _ &lt;&gt; (Snd a) = (Snd a)
  _ &lt;&gt; b = b

instance (Arbitrary a, Arbitrary b) =&gt; Arbitrary (Or a b) where
  arbitrary = do
    a &lt;- arbitrary
    b &lt;- arbitrary
    elements [(Fst a), (Snd b)]

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type OrAssoc = Or String Ordering -&gt; Or String Ordering -&gt; Or String Ordering -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: OrAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype Combine a b = Combine { unCombine :: (a &#8594; b) }</code></p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
could not break the <code>CoArbitrary</code>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;), Sum(Sum, getSum))

newtype Combine a b = Combine { unCombine :: (a -&gt; b) }

instance Semigroup b =&gt; Semigroup (Combine a b) where
  Combine {unCombine=f} &lt;&gt; Combine {unCombine=g} = Combine (f &lt;&gt; g)

-- instance (Arbitrary a, Arbitrary b) =&gt; Arbitrary (Combine a b) where
--   arbitrary = do
--     a &lt;- arbitrary
--     b &lt;- arbitrary
--     elements [(Fst a), (Snd b)]

-- instance CoArbitrary a =&gt; CoArbitrary (Combine a b) where
--   coarbitrary Combine { unCombine = (a -&gt; b) }  = variant 0
--   coarbitrary (Just x) = variant 1 . coarbitrary x

-- semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
-- semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

-- type CombineAssoc = Combine String Ordering -&gt; Combine String Ordering -&gt; Combine String Ordering -&gt; Bool

-- main :: IO ()
-- main =
--   quickCheck (semigroupAssoc :: CombineAssoc)

f = Combine $ \n -&gt; Sum (n + 1)
g = Combine $ \n -&gt; Sum (n - 1)

main = do
  print $ unCombine (f &lt;&gt; g ) $ 0
  print $ unCombine (f &lt;&gt; g ) $ 1
  print $ unCombine (f &lt;&gt; f ) $ 1
  print $ unCombine (g &lt;&gt; f ) $ 1</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype Comp a = Comp { unComp :: (a &#8594; a) }</code></p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
probably correct, do not undestand
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;), Sum(..))

newtype Comp a = Comp { unComp :: (a -&gt; a) }

instance Semigroup a =&gt; Semigroup (Comp a) where
  Comp {unComp=f} &lt;&gt; Comp {unComp=g} = Comp (f &lt;&gt; g)


f = Comp $ \(Sum n) -&gt; Sum (n + 1)
g = Comp $ \(Sum n) -&gt; Sum (n - 1)

main = do
  print $ unComp (f &lt;&gt; g ) $ 0
  print $ unComp (f &lt;&gt; g ) $ 1
  print $ unComp (f &lt;&gt; f ) $ 1
  print $ unComp (g &lt;&gt; f ) $ 1</code></pre>
</div>
</div>
</li>
<li>
<p><code>data Validation a b = Failure a | Success b deriving (Eq, Show)</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;))

data Validation a b =
  Failure a | Success b
  deriving (Eq, Show)

instance Semigroup a =&gt;
  Semigroup (Validation a b) where
    (Failure a) &lt;&gt; (Failure b)  = Failure (a &lt;&gt; b)
    (Failure a) &lt;&gt; _            = Failure a
    _           &lt;&gt; (Failure a)  = Failure a
    a           &lt;&gt; _            = a

instance (Arbitrary a, Arbitrary b) =&gt; Arbitrary (Validation a b) where
  arbitrary = do
    a &lt;- arbitrary
    b &lt;- arbitrary
    elements [(Success a), (Failure b)]

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type ValidationAssoc = Validation String Ordering -&gt; Validation String Ordering -&gt; Validation String Ordering -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: ValidationAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype AccumulateRight a b = AccumulateRight (Validation a b) deriving (Eq, Show)</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;))

data Validation a b =
  Failure a | Success b
  deriving (Eq, Show)

newtype AccumulateRight a b =
  AccumulateRight (Validation a b)
  deriving (Eq, Show)

instance Semigroup b =&gt;
  Semigroup (AccumulateRight a b) where
    (AccumulateRight (Success a)) &lt;&gt; (AccumulateRight (Success b))  = AccumulateRight (Success (a &lt;&gt; b))
    (AccumulateRight (Failure a)) &lt;&gt; _                              = AccumulateRight (Failure a)
    _                             &lt;&gt; (AccumulateRight (Failure a))  = AccumulateRight (Failure a)

instance (Arbitrary a, Arbitrary b) =&gt; Arbitrary (AccumulateRight a b) where
  arbitrary = do
    a &lt;- arbitrary
    b &lt;- arbitrary
    elements [(AccumulateRight (Success a)), (AccumulateRight (Failure b))]

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type AccumulateRightAssoc = AccumulateRight String Ordering -&gt; AccumulateRight String Ordering -&gt; AccumulateRight String Ordering -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: AccumulateRightAssoc)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype AccumulateBoth a b = AccumulateBoth (Validation a b) deriving (Eq, Show)</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;))

data Validation a b =
  Failure a | Success b
  deriving (Eq, Show)

newtype AccumulateBoth a b =
  AccumulateBoth (Validation a b)
  deriving (Eq, Show)

instance (Semigroup a, Semigroup b) =&gt;
  Semigroup (AccumulateBoth a b) where
    (AccumulateBoth (Success a)) &lt;&gt; (AccumulateBoth (Success b))  = AccumulateBoth (Success (a &lt;&gt; b))
    (AccumulateBoth (Failure a)) &lt;&gt; (AccumulateBoth (Failure b))  = AccumulateBoth (Failure (a &lt;&gt; b))
    _                            &lt;&gt; (AccumulateBoth (Failure a))  = AccumulateBoth (Failure a)
    (AccumulateBoth (Failure a)) &lt;&gt; _                             = AccumulateBoth (Failure a)

instance (Arbitrary a, Arbitrary b) =&gt; Arbitrary (AccumulateBoth a b) where
  arbitrary = do
    a &lt;- arbitrary
    b &lt;- arbitrary
    elements [(AccumulateBoth (Success a)), (AccumulateBoth (Failure b))]

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

type AccumulateBothAssoc = AccumulateBoth String Ordering -&gt; AccumulateBoth String Ordering -&gt; AccumulateBoth String Ordering -&gt; Bool

main :: IO ()
main =
  quickCheck (semigroupAssoc :: AccumulateBothAssoc)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_monoid_exercises">Monoid exercises</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>data Trivial = Trivial deriving (Eq, Show)</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck)
import Data.Semigroup (Semigroup, (&lt;&gt;))
import Data.Monoid (Monoid)

data Trivial = Trivial deriving (Eq, Show)

instance Semigroup Trivial where
  _ &lt;&gt; _ = Trivial

instance Monoid Trivial where
  mempty = Trivial
  mappend = (&lt;&gt;)

instance Arbitrary Trivial where
  arbitrary = return Trivial

type TrivialAssoc = Trivial -&gt; Trivial -&gt; Trivial -&gt; Bool

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

monoidLeftIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidLeftIdentity a = (mempty &lt;&gt; a) == a

monoidRightIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidRightIdentity a = (a &lt;&gt; mempty) == a

main :: IO ()
main = do
  quickCheck (semigroupAssoc :: TrivialAssoc)
  quickCheck (monoidLeftIdentity :: Trivial -&gt; Bool)
  quickCheck (monoidRightIdentity :: Trivial -&gt; Bool)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype Identity a = Identity a deriving (Eq, Show)</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck)
import Data.Semigroup (Semigroup, (&lt;&gt;))
import Data.Monoid (Monoid)

newtype Identity a = Identity a deriving (Eq, Show)

instance Semigroup a =&gt; Semigroup (Identity a) where
  (Identity a) &lt;&gt; (Identity b) = Identity (a &lt;&gt; b)

instance (Semigroup a, Monoid a) =&gt; Monoid (Identity a) where
  mempty = Identity mempty
  mappend = (&lt;&gt;)

instance Arbitrary a =&gt; Arbitrary (Identity a) where
  arbitrary = do
    a &lt;- arbitrary
    return (Identity a)

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

monoidLeftIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidLeftIdentity a = (mempty &lt;&gt; a) == a

monoidRightIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidRightIdentity a = (a &lt;&gt; mempty) == a

type IdentityAssoc = Identity String -&gt; Identity String -&gt; Identity String -&gt; Bool

main :: IO ()
main = do
  quickCheck (semigroupAssoc :: IdentityAssoc)
  quickCheck (monoidLeftIdentity :: Identity String -&gt; Bool)
  quickCheck (monoidRightIdentity :: Identity String -&gt; Bool)</code></pre>
</div>
</div>
</li>
<li>
<p><code>data Two a b = Two a b</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck)
import Data.Semigroup (Semigroup, (&lt;&gt;))
import Data.Monoid (Monoid)

data Two a b = Two a b deriving (Eq, Show)

instance (Semigroup a, Semigroup b) =&gt; Semigroup (Two a b) where
  (Two a b) &lt;&gt; (Two c d) = Two (a &lt;&gt; c) (b &lt;&gt; d)

instance (Semigroup a, Monoid a, Semigroup b, Monoid b) =&gt; Monoid (Two a b) where
  mempty = Two mempty mempty
  mappend = (&lt;&gt;)

instance (Arbitrary a, Arbitrary b) =&gt; Arbitrary (Two a b) where
  arbitrary = do
    a &lt;- arbitrary
    b &lt;- arbitrary
    return (Two a b)

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

monoidLeftIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidLeftIdentity a = (mempty &lt;&gt; a) == a

monoidRightIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidRightIdentity a = (a &lt;&gt; mempty) == a

type TwoAssoc = Two String Ordering -&gt; Two String Ordering -&gt; Two String Ordering -&gt; Bool

main :: IO ()
main = do
  quickCheck (semigroupAssoc :: TwoAssoc)
  quickCheck (monoidLeftIdentity :: Two String Ordering -&gt; Bool)
  quickCheck (monoidRightIdentity :: Two String Ordering -&gt; Bool)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype BoolConj = BoolConj Bool</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;))
import Data.Monoid (Monoid)

newtype BoolConj = BoolConj Bool deriving (Eq, Show)

instance Semigroup BoolConj where
  (BoolConj a) &lt;&gt; (BoolConj b) = BoolConj (a &amp;&amp; b)

instance Monoid BoolConj where
  mempty = BoolConj True
  mappend = (&lt;&gt;)

instance Arbitrary BoolConj where
  arbitrary = do
    a &lt;- arbitrary
    elements [(BoolConj a), (BoolConj a)]

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

monoidLeftIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidLeftIdentity a = (mempty &lt;&gt; a) == a

monoidRightIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidRightIdentity a = (a &lt;&gt; mempty) == a

type BoolConjAssoc = BoolConj -&gt; BoolConj -&gt; BoolConj -&gt; Bool

main :: IO ()
main = do
  quickCheck (semigroupAssoc :: BoolConjAssoc)
  quickCheck (monoidLeftIdentity :: BoolConj -&gt; Bool)
  quickCheck (monoidRightIdentity :: BoolConj -&gt; Bool)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype BoolDisj = BoolDisj Bool</code></p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;))
import Data.Monoid (Monoid)

newtype BoolDisj = BoolDisj Bool deriving (Eq, Show)

instance Semigroup BoolDisj where
  (BoolDisj a) &lt;&gt; (BoolDisj b) = BoolDisj (a || b)

instance Monoid BoolDisj where
  mempty = BoolDisj False
  mappend = (&lt;&gt;)

instance Arbitrary BoolDisj where
  arbitrary = do
    a &lt;- arbitrary
    elements [(BoolDisj a), (BoolDisj a)]

semigroupAssoc :: (Eq m, Semigroup m) =&gt; m -&gt; m -&gt; m -&gt; Bool
semigroupAssoc a b c = (a &lt;&gt; (b &lt;&gt; c)) == ((a &lt;&gt; b) &lt;&gt; c)

monoidLeftIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidLeftIdentity a = (mempty &lt;&gt; a) == a

monoidRightIdentity :: (Eq m, Monoid m, Semigroup m) =&gt; m -&gt; Bool
monoidRightIdentity a = (a &lt;&gt; mempty) == a

type BoolDisjAssoc = BoolDisj -&gt; BoolDisj -&gt; BoolDisj -&gt; Bool

main :: IO ()
main = do
  quickCheck (semigroupAssoc :: BoolDisjAssoc)
  quickCheck (monoidLeftIdentity :: BoolDisj -&gt; Bool)
  quickCheck (monoidRightIdentity :: BoolDisj -&gt; Bool)</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype Combine a b = Combine { unCombine :: (a &#8594; b) }</code></p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
could not break the <code>CoArbitrary</code>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;), Sum(Sum, getSum))
import Data.Monoid (Monoid)

newtype Combine a b = Combine { unCombine :: (a -&gt; b) }

instance Semigroup b =&gt; Semigroup (Combine a b) where
  Combine {unCombine=f} &lt;&gt; Combine {unCombine=g} = Combine (f &lt;&gt; g)

instance (Semigroup b, Monoid b) =&gt; Monoid (Combine a b) where
  mempty = Combine mempty
  mappend = (&lt;&gt;)

f = Combine $ \n -&gt; Sum (n + 1)
g = Combine $ \n -&gt; Sum (n - 1)

main = do
  print $ unCombine (f &lt;&gt; g ) $ 0
  print $ unCombine (f &lt;&gt; g ) $ 1
  print $ unCombine (f &lt;&gt; f ) $ 1
  print $ unCombine (g &lt;&gt; f ) $ 1
  print $ unCombine (mappend mempty f) 0 == unCombine f 0</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype Comp a = Comp { unComp :: (a &#8594; a) }</code></p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
how come <code>unComp f 0</code> does not break?
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Test.QuickCheck (Arbitrary, arbitrary, quickCheck, elements)
import Data.Semigroup (Semigroup, (&lt;&gt;), Sum(..))
import Data.Monoid (Monoid)

newtype Comp a = Comp { unComp :: (a -&gt; a) }

instance Semigroup a =&gt; Semigroup (Comp a) where
  Comp {unComp=f} &lt;&gt; Comp {unComp=g} = Comp (f &lt;&gt; g)

instance (Semigroup a, Monoid a) =&gt; Monoid (Comp a) where
  mempty = Comp id
  mappend = (&lt;&gt;)


f = Comp $ \(Sum n) -&gt; Sum (n + 1)
g = Comp $ \(Sum n) -&gt; Sum (n - 1)

main = do
  print $ unComp (f &lt;&gt; g ) $ 0
  print $ unComp (f &lt;&gt; g ) $ 1
  print $ unComp (f &lt;&gt; f ) $ 1
  print $ unComp (g &lt;&gt; f ) $ 1
  print $ unComp (mappend mempty f) 0 == unComp f 0</code></pre>
</div>
</div>
</li>
<li>
<p><code>newtype Mem s a&#8230;&#8203;.</code></p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
awkward, what is this for? and again, no <code>CoArbitrary</code>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">import Data.Monoid (Monoid, (&lt;&gt;))

newtype Mem s a =
  Mem {
    runMem :: s -&gt; (a,s)
  }

instance Monoid a =&gt; Monoid (Mem s a) where
  mempty = Mem $ \s -&gt; (mempty, s)
  mappend Mem {runMem = f} Mem {runMem = g} = Mem $ \x -&gt; let (a, b) = g x
                                                              (c, d) = f b
                                                          in (a &lt;&gt; c, d)


f' = Mem $ \s -&gt; ("hi", s + 1)
main = do
  print $ runMem (f' &lt;&gt; mempty) 0
  print $ runMem (mempty &lt;&gt; f') 0
  print $ (runMem mempty 0 :: (String, Int))
  print $ runMem (f' &lt;&gt; mempty) 0 == runMem f' 0
  print $ runMem (mempty &lt;&gt; f') 0 == runMem f' 0</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_16_functor">16 Functor</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_116_4_let_s_talk_about_f_baby">116.4 Let’s talk about f , baby</h3>
<div class="sect3">
<h4 id="_intermission_exercises_24">Intermission: Exercises</h4>
<div class="paragraph">
<p>because kind of <code>(&#8594;)</code> is <code>(&#8594;) :: * &#8594; * &#8594; *</code> the following is</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>kind of <code>a</code> if <code>*</code></p>
</li>
<li>
<p><code>b</code> has kind <code>* &#8594; *</code>, <code>T</code> has kind <code>* &#8594; *</code></p>
</li>
<li>
<p><code>c</code> has kind <code>* &#8594; * &#8594; *</code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_16_7_commonly_used_functors">16.7 Commonly used functors</h3>
<div class="sect3">
<h4 id="_the_functors_are_stacked_and_that_s_a_fact">The functors are stacked and that’s a fact</h4>
<div class="paragraph">
<p>little write out of what happens when we compose functors</p>
</div>
<div class="literalblock">
<div class="content">
<pre>replaceWithP = const 'p'

:t replaceWithP
replaceWithP :: b -&gt; Char

lms = [Just "Ave", Nothing, Just "woohoo"]

now we try try to this:
(fmap . fmap) replaceWithP lms
and the result is:
[Just 'p',Nothing,Just 'p']

let's disect this:

:t (fmap . fmap)
(Functor f, Functor f1) =&gt; (a -&gt; b) -&gt; f (f1 a) -&gt; f (f1 b)

fmap :: Functor f =&gt; (m -&gt; n) -&gt; f m -&gt; f n

fmap :: Functor g =&gt; (x -&gt; y) -&gt; g x -&gt; g y


(x -&gt; y) -&gt; g x -&gt; g y
apply: replaceWithP :: b -&gt; Char
result is:
g b -&gt; g Char
that is (b -&gt; Char) substitued in (g x -&gt; g y)

(m -&gt; n) -&gt; f m -&gt; f n
apply: (g b -&gt; g Char)
result is:
f (g b) -&gt; f (g Char)
that is (b -&gt; Char) substitued in (f m -&gt; f n)


f (g b) -&gt; f (g Char)
apply: lms
result is:
f unwraps the list
g unwraps the Maybe
replaceWithP is applied to the value

voilà, it does work as advertised :)

three compositions go one more level deeper
(fmap . fmap . fmap)
as we can also fmap over String</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_one_more_round_for_the_p_funkshun">One more round for the P-Funkshun</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-haskell" data-lang="haskell">replaceWithP :: b -&gt; Char
replaceWithP = const 'p'

lms :: [Maybe [Char]]
lms = [Just "Ave", Nothing, Just "woohoo"]

-- Just making the argument more specific
replaceWithP' :: [Maybe [Char]] -&gt; Char
replaceWithP' = replaceWithP

-- Prelude&gt; :t fmap replaceWithP
-- fmap replaceWithP :: Functor f =&gt; f a -&gt; f Char

liftedReplace :: Functor f =&gt; f a -&gt; f Char
liftedReplace = fmap replaceWithP

liftedReplace' :: [Maybe [Char]] -&gt; [Char]
liftedReplace' = liftedReplace

-- Prelude&gt; :t (fmap . fmap) replaceWithP
-- (fmap . fmap) replaceWithP
--   :: (Functor f1, Functor f) =&gt; f (f1 a) -&gt; f (f1 Char)
twiceLifted :: (Functor f1, Functor f) =&gt; f (f1 a) -&gt; f (f1 Char)
twiceLifted = (fmap . fmap) replaceWithP

-- Making it more specific
twiceLifted' :: [Maybe [Char]] -&gt; [Maybe Char]
twiceLifted' = twiceLifted
-- f ~ []
-- f1 ~ Maybe

-- Prelude&gt; :t (fmap . fmap . fmap) replaceWithP
-- (fmap . fmap . fmap) replaceWithP
--   :: (Functor f2, Functor f1, Functor f) =&gt;
--      f (f1 (f2 a)) -&gt; f (f1 (f2 Char))
thriceLifted :: (Functor f2, Functor f1, Functor f) =&gt; f (f1 (f2 a)) -&gt; f (f1 (f2 Char))
thriceLifted = (fmap . fmap . fmap) replaceWithP

-- More specific or "concrete"
thriceLifted' :: [Maybe [Char]] -&gt; [Maybe [Char]]
thriceLifted' = thriceLifted
-- f ~ []
-- f1 ~ Maybe
-- f2 ~ []

main :: IO ()
main = do
  putStr "replaceWithP' lms:"
  print (replaceWithP' lms)

  putStr "liftedReplace lms:"
  print (liftedReplace lms)
  putStr "liftedReplace' lms:"
  print (liftedReplace' lms)
  putStr "twiceLifted lms:"
  print (twiceLifted lms)
  putStr "twiceLifted' lms:"
  print (twiceLifted' lms)
  putStr "thriceLifted lms:"
  print (thriceLifted lms)
  putStr "thriceLifted' lms:"
  print (thriceLifted' lms)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_intermission_lifting_exercises">Intermission: Lifting Exercises</h4>

</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2016-04-08 13:32:58 CEST
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>